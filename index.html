<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio-Line // CMLRE Initiative</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="database_search.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #e5e7eb;
            --grid-color: rgba(255, 255, 255, 0.07);
            background-image:
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 30px 30px;
        }
        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }

        /* --- MODIFICATION 1: Position the Spline model as a background element on the right --- */
       spline-viewer {
            position: fixed; /* Fixed position relative to the viewport */
            top: 0;
            right: 0;
            width: 50vw; /* Occupies the right half of the screen */
            height: 100vh;
            z-index: 0; /* Sits behind the content */
            transform: scale(2.5); /* --- MODIFICATION: "Super zoom" the model by 2.5x --- */
            transform-origin: center; /* Ensure it zooms from the center */
            transition: opacity 0.3s ease; /* Smooth transition when hiding */
            
            /* * --- MODIFICATION: Enable Model Interaction --- 
             * The 'pointer-events: none;' property has been removed.
             * This allows mouse events (like scrolling to zoom, clicking, and dragging)
             * to be captured by the Spline model instead of passing through it.
             * Now, you can interact with the 3D model directly.
            */
        }


        .content-wrapper {
            position: relative;
            z-index: 1; /* Ensures content is on top of the spline model */
        }
        .card {
            background-color: rgba(26, 26, 26, 0.6);
            border: 1px solid #3f3f46;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }
        .btn-primary {
            background-color: transparent;
            color: #ffffff;
            transition: all 0.3s ease;
            border: 1px solid #ffffff;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        .btn-primary:hover {
            background-color: #ffffff;
            color: #000000;
        }
        .btn-primary:disabled {
            color: #6b7280;
            border-color: #3f3f46;
            background-color: transparent;
            cursor: not-allowed;
        }
        .btn-secondary {
            background-color: transparent;
            color: #a1a1aa;
            border: 1px solid #3f3f46;
        }
        .btn-secondary:hover {
             background-color: #27272a;
             color: #ffffff;
        }
        .reveal {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s ease-out, transform 0.8s ease-out;
        }
        .reveal.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .section-title {
            color: #ffffff;
            font-size: 1rem;
            font-weight: 500;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            font-family: 'Roboto Mono', monospace;
        }
        .line {
            height: 1px;
            background-color: #27272a;
            flex-grow: 1;
        }
        .text-scramble {
            display: inline-block;
        }
        .blinking-cursor {
            color: white;
            animation: blink 1s step-end infinite;
        }
        @keyframes blink {
            50% { opacity: 0; }
        }
        #reportModal.hidden, #chatbot-container.hidden {
            display: none;
        }
        
        /* Custom scrollbar for results table */
        #classificationResult::-webkit-scrollbar {
            height: 6px;
        }
        #classificationResult::-webkit-scrollbar-track {
            background: #000;
        }
        #classificationResult::-webkit-scrollbar-thumb {
            background: #27272a;
            border-radius: 3px;
        }
        #classificationResult::-webkit-scrollbar-thumb:hover {
            background: #3f3f46;
        }
        
        /* Force Chart.js canvas text to be white */
        canvas {
            color: #ffffff !important;
        }
    </style>
</head>

<body class="antialiased">
    <script type="module" src="https://unpkg.com/@splinetool/viewer@1.10.68/build/spline-viewer.js"></script>
    <spline-viewer url="https://prod.spline.design/j-bDax7HxMeYiO4s/scene.splinecode"></spline-viewer>

    <div class="content-wrapper">
        <div id="homePage">
            <header class="fixed top-0 left-0 right-0 z-50">
                <nav class="container mx-auto px-6 py-4 flex justify-between items-center border-b border-gray-800 bg-black/50 backdrop-blur-md">
                    <div class="text-lg font-bold text-white tracking-widest"><a href="#">Bio-Line</a></div>
                    <div class="hidden md:flex items-center space-x-8 text-sm uppercase font-mono">
                        <a href="#problem" class="text-gray-400 hover:text-white transition">01_Problem</a>
                        <a href="#solution" class="text-gray-400 hover:text-white transition">02_Solution</a>
                        <a href="#tech" class="text-gray-400 hover:text-white transition">03_System</a>
                    </div>
                    <button id="loginBtn" class="btn-primary font-medium py-2 px-4 text-xs font-mono">Engage Platform</button>
                </nav>
            </header>
            <main class="container mx-auto px-6">
                <section class="min-h-screen flex flex-col justify-center items-start pt-20">
                    <div class="w-full lg:w-1/2">
                        <div class="text-left">
                            <h1 class="text-3xl md:text-5xl font-bold text-white leading-tight mb-4 font-mono">
                                <span class="text-scramble" data-text="AI-DRIVEN eDNA ANALYSIS"></span>
                                <span class="blinking-cursor">_</span>
                            </h1>
                            <p class="text-base text-gray-400 mb-8 max-w-lg">
                                A high-throughput pipeline to classify eukaryotic taxa and assess deep-sea biodiversity directly from raw environmental DNA, bypassing the limitations of conventional reference databases.
                            </p>
                            <a href="#problem" class="btn-primary font-semibold py-3 px-6 text-sm">View Mission Brief</a>
                        </div>
                    </div>
                </section>
                 <section id="problem" class="py-24">
                     <div data-reveal class="flex items-center gap-4 mb-12"><span class="section-title text-gray-500">01</span><span class="section-title">Problem Statement</span><div class="line"></div></div>
                     <div class="grid md:grid-cols-2 gap-8">
                         <div class="card p-8 reveal rounded-lg" data-reveal><h3 class="text-xl font-bold text-white mb-4">// Incomplete Databases</h3><p class="text-gray-400">Deep-sea organisms are critically underrepresented in genetic reference databases. This data void results in misclassification, unassigned reads, and a fundamental underestimation of true biodiversity.</p></div>
                         <div class="card p-8 reveal rounded-lg" data-reveal style="transition-delay: 150ms"><h3 class="text-xl font-bold text-white mb-4">// Computational Bottlenecks</h3><p class="text-gray-400">Legacy bioinformatic pipelines are computationally expensive and inefficient for novel discovery. Their reliance on sequence alignment against flawed databases is a primary limiting factor.</p></div>
                     </div>
                 </section>
                
                 <section id="solution" class="py-24">
                     <div data-reveal class="flex items-center gap-4 mb-12"><span class="section-title text-gray-500">02</span><span class="section-title">Proposed Solution</span><div class="line"></div></div>
                     <div class="grid grid-cols-1 gap-8">
                         <div class="card p-8 md:p-12 reveal rounded-lg" data-reveal>
                            <p class="text-base text-gray-300 leading-relaxed">Our AI-driven pipeline leverages deep learning and unsupervised clustering to analyze eDNA without primary reliance on existing databases. The system is designed to:</p>
                             <ul class="mt-8 space-y-6 text-sm">
                                 <li class="flex items-start"><span class="text-white mr-4 mt-1 font-mono">[+]</span><span><strong class="text-white font-semibold">CLASSIFY TAXA DIRECTLY:</strong> A fine-tuned DNA-BERT transformer model interprets raw sequence data, enabling classification without perfect database matches.</span></li>
                                 <li class="flex items-start"><span class="text-white mr-4 mt-1 font-mono">[+]</span><span><strong class="text-white font-semibold">DISCOVER NOVEL SPECIES:</strong> Unsupervised clustering algorithms (DBSCAN, k-means) identify and group unknown sequences, flagging potential new taxa for targeted analysis.</span></li>
                                  <li class="flex items-start"><span class="text-white mr-4 mt-1 font-mono">[+]</span><span><strong class="text-white font-semibold">GENERATE ECOLOGICAL INSIGHTS:</strong> Rapidly produce accurate estimations of species abundance and community structure to inform conservation and research priorities.</span></li>
                             </ul>
                         </div>
                     </div>
                 </section>

                 <section id="tech" class="py-24">
                     <div data-reveal class="flex items-center gap-4 mb-12"><span class="section-title text-gray-500">03</span><span class="section-title">System Architecture</span><div class="line"></div></div>
                     <div class="card p-8 flex justify-center items-center reveal rounded-lg" data-reveal>
                        <p class="text-center text-gray-400 max-w-4xl text-sm font-mono">SYSTEM INGESTS RAW eDNA DATA -> PREPROCESSING MODULE EXTRACTS 18S rRNA & COI MARKERS -> DATA IS VECTORIZED BY A FINE-TUNED DNA-BERT TRANSFORMER -> EMBEDDINGS ARE PROCESSED VIA DUAL PATHWAYS: [A] DEEP LEARNING FOR CLASSIFICATION, [B] UNSUPERVISED CLUSTERING FOR NOVELTY DETECTION -> OUTPUT GENERATION: TAXONOMIC GROUPING, ABUNDANCE ESTIMATION, ECOLOGICAL INSIGHTS.</p>
                     </div>
                 </section>
                 <div class="h-24"></div>
            </main>
        </div>

        <div id="loginPage" class="hidden min-h-screen flex items-center justify-center p-4">
               <div class="w-full max-w-sm">
                       <div class="card p-8 space-y-6 border border-[#27272a] rounded-lg">
                           <h2 class="text-lg font-bold text-center text-white tracking-widest font-mono">// AUTHENTICATION REQUIRED</h2>
                           <div>
                               <div class="flex border border-[#27272a] rounded-md overflow-hidden"><button id="userToggle" class="w-1/2 py-2 text-sm font-medium bg-white text-black">USER</button><button id="adminToggle" class="w-1/2 py-2 text-sm font-medium text-gray-400">ADMIN</button></div>
                           </div>
                           <form id="loginForm" class="space-y-4">
                               <div><label for="email" class="text-xs font-medium text-gray-400 font-mono">EMAIL_ADDR</label><input type="email" id="email" class="w-full mt-1 p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white focus:border-white outline-none text-sm" value="user@cmlre.gov"></div>
                               <div><label for="password" class="text-xs font-medium text-gray-400 font-mono">PASSWORD</label><input type="password" id="password" class="w-full mt-1 p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white focus:border-white outline-none" value="password"></div>
                               <button type="submit" class="w-full btn-primary font-bold py-3 px-4 text-xs rounded-md">EXECUTE LOGIN</button>
                           </form>
                       </div>
               </div>
        </div>

        <div id="dashboardPage" class="hidden min-h-screen container mx-auto px-6 py-24">
            <div class="flex justify-between items-center mb-8 border-b border-[#27272a] pb-4">
                <h1 class="text-xl font-bold text-white tracking-widest font-mono">// ANALYSIS DASHBOARD</h1>
                <button id="logoutBtn" class="text-gray-400 hover:text-white transition text-xs uppercase font-mono">LOGOUT</button>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
                <div class="card p-6 border border-[#27272a] rounded-lg">
                    <h2 class="text-lg font-semibold text-white mb-4 font-mono">// SINGLE SEQUENCE ANALYSIS</h2>
                    <textarea id="dnaSequenceInput" rows="4" class="w-full p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white outline-none text-sm font-mono" placeholder="> Paste raw eDNA sequence here..."></textarea>
                    <div class="mt-4 text-right">
                        <button id="analyzeBtn" class="btn-primary font-bold py-2 px-5 text-xs rounded-md">INITIATE ANALYSIS</button>
                    </div>
                </div>
                <div class="card p-6 border border-[#27272a] rounded-lg">
                    <h2 class="text-lg font-semibold text-white mb-4 font-mono">// BATCH ANALYSIS (CSV/FASTA)</h2>
                    <p class="text-xs text-gray-400 mb-2">Upload a CSV file with 'sample_id' and 'sequence' columns, or a FASTA file with sequences.</p>
                    
                    <!-- Format Examples -->
                    <details class="mb-2">
                        <summary class="text-xs text-blue-400 cursor-pointer hover:text-blue-300 transition">View format examples</summary>
                        <div class="mt-2 p-3 bg-black/50 border border-gray-800 rounded text-xs font-mono space-y-3">
                            <div>
                                <div class="text-gray-400 mb-1">CSV Format:</div>
                                <code class="text-green-400 block">sample_id,sequence<br>sample_1,ATCGATCGATCG<br>sample_2,GCTAGCTAGCTA</code>
                            </div>
                            <div>
                                <div class="text-gray-400 mb-1">FASTA Format:</div>
                                <code class="text-green-400 block">>sample_1<br>ATCGATCGATCG<br>>sample_2<br>GCTAGCTAGCTA</code>
                            </div>
                        </div>
                    </details>
                    
                    <!-- Download Sample Files -->
                    <details class="mb-4">
                        <summary class="text-xs text-blue-400 cursor-pointer hover:text-blue-300 transition">Download sample</summary>
                        <div class="mt-2 p-3 bg-black/50 border border-gray-800 rounded text-xs space-y-2">
                            <div>
                                <a href="sample_sequences.csv" download class="text-blue-400 hover:text-blue-300 transition cursor-pointer">sample.csv (15 sequences)</a>
                            </div>
                            <div>
                                <a href="sample_sequences.fasta" download class="text-blue-400 hover:text-blue-300 transition cursor-pointer">sample.fasta (15 sequences)</a>
                            </div>
                        </div>
                    </details>
                    
                    <input type="file" id="csvFileInput" class="hidden" accept=".csv,.fasta,.fa,.fna,.txt">
                    <button id="csvUploadBtn" class="w-full border border-dashed border-[#27272a] hover:border-white transition py-4 text-gray-400 text-sm rounded-md">
                        CLICK TO UPLOAD CSV/FASTA FILE
                    </button>
                   
                    <div class="mt-4 space-y-3">
                        <div>
                            <label for="environmentType" class="text-xs font-medium text-gray-400 font-mono">ENVIRONMENT TYPE</label>
                            <input type="text" id="environmentType" placeholder="e.g. Hydrothermal Vent" class="w-full mt-1 p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white focus:border-white outline-none text-sm">
                        </div>
                        <div>
                            <label for="batchDepth" class="text-xs font-medium text-gray-400 font-mono">DEPTH (meters)</label>
                            <input type="number" id="batchDepth" step="1" placeholder="e.g. 2500" class="w-full mt-1 p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white focus:border-white outline-none text-sm">
                        </div>
                    </div>
                   
                    <div class="mt-4 text-right">
                        <button id="batchAnalyzeBtn" class="btn-primary font-bold py-2 px-5 text-xs rounded-md" disabled>ANALYZE BATCH</button>
                    </div>
                </div>
            </div>

            <div id="resultsSection" class="hidden">
                 <div class="mb-8 card border border-[#27272a] p-4 rounded-lg">
                     <h3 class="text-lg font-semibold text-white mb-4 font-mono">// PIPELINE STATUS</h3>
                     <div id="pipelineStatus" class="text-xs font-mono"></div>
                 </div>

                 <div id="markerResultsCard" class="hidden mb-8 card border border-[#27272a] p-6 rounded-lg">
                     <h3 class="text-lg font-semibold text-white mb-4 font-mono">// GENE MARKER DETECTION</h3>
                     <div id="markerResultsContent"></div>
                 </div>

                <!-- Diversity Metrics Card -->
                <div id="diversityMetricsCard" class="hidden mb-8 card border border-[#27272a] p-6 rounded-lg">
                    <h3 class="text-lg font-semibold text-white mb-4 font-mono">// DIVERSITY METRICS</h3>
                    <div id="diversityMetricsContent"></div>
                </div>

                <!-- Clustering Analysis Card -->
                <div id="clusteringCard" class="hidden mb-8 card border border-[#27272a] p-6 rounded-lg">
                    <div class="mb-4">
                        <h3 class="text-lg font-semibold text-white font-mono">// ORGANISM CLUSTERING ANALYSIS</h3>
                        <p class="text-gray-400 text-xs mt-2">Taxonomic relationships visualized using 2D UMAP clustering</p>
                    </div>
                    <div id="clusteringContent">
                        <div id="clusteringResults" class="hidden">
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                                <!-- Stat Cards -->
                                <div class="bg-gradient-to-br from-blue-500/10 to-blue-600/5 border border-blue-500/30 rounded-lg p-4">
                                    <div class="text-xs text-blue-400 uppercase tracking-wider mb-1">Total Clusters</div>
                                    <div class="text-3xl font-bold text-white" id="totalClustersCount">0</div>
                                </div>
                                <div class="bg-gradient-to-br from-green-500/10 to-green-600/5 border border-green-500/30 rounded-lg p-4">
                                    <div class="text-xs text-green-400 uppercase tracking-wider mb-1">Clustered</div>
                                    <div class="text-3xl font-bold text-white" id="clusteredCount">0</div>
                                </div>
                                <div class="bg-gradient-to-br from-yellow-500/10 to-yellow-600/5 border border-yellow-500/30 rounded-lg p-4">
                                    <div class="text-xs text-yellow-400 uppercase tracking-wider mb-1">Novel/Outliers</div>
                                    <div class="text-3xl font-bold text-white" id="novelClusterCount">0</div>
                                </div>
                            </div>
                            
                            <!-- Cluster Scatter Plot -->
                            <div class="mb-6">
                                <h4 class="text-sm font-semibold text-white mb-3 font-mono">Cluster Distribution (2D UMAP)</h4>
                                <div class="bg-black/50 p-4 rounded-lg border border-[#27272a]">
                                    <canvas id="clusterScatterChart" height="300"></canvas>
                                </div>
                            </div>
                            
                            <!-- Cluster Details -->
                            <div id="clusterDetails" class="space-y-3"></div>
                        </div>
                    </div>
                </div>

                <!-- Taxonomic Classification Results - Full Width -->
                <div class="mb-8 card p-6 border border-[#27272a] rounded-lg">
                    <div class="flex justify-between items-center flex-wrap gap-2 mb-4">
                        <h3 class="text-lg font-semibold text-white font-mono">// TAXONOMIC CLASSIFICATION RESULTS</h3>
                        <div class="flex items-center gap-2">
                            <button id="verifyDatabaseBtn" class="hidden btn-secondary font-bold py-2 px-4 text-xs rounded-md">
                                🔍 Verify Novel Species
                            </button>
                            <button id="exportResultsBtn" class="hidden btn-secondary font-bold py-2 px-4 text-xs rounded-md">Export CSV</button>
                        </div>
                    </div>
                    <div id="classificationResult" class="text-sm">
                        <p class="text-gray-500">Results will appear here after analysis.</p>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <div class="lg:col-span-2 space-y-8">
                        <div id="insightsCard" class="card p-6 border border-[#27272a] rounded-lg">
                             <div class="flex justify-between items-center flex-wrap gap-2 mb-4">
                                 <h3 class="text-lg font-semibold text-white font-mono">// ECOLOGICAL INSIGHTS REPORT</h3>
                                 <div class="flex items-center gap-2">
                                     <button id="chatBtn" class="hidden btn-secondary font-bold py-2 px-5 text-xs rounded-md">Chat with AI</button>
                                     <button id="generateReportBtn" class="hidden btn-primary font-bold py-2 px-5 text-xs rounded-md">Generate Report</button>
                                 </div>
                             </div>
                            <div id="insightsResult" class="space-y-6 text-sm">
                                <p class="text-gray-500">Ecological insights will be generated after batch analysis is complete.</p>
                            </div>
                        </div>
                    </div>
                    <div class="space-y-8">
                        <div class="card p-6 border border-[#27272a] rounded-lg">
                            <h3 class="text-lg font-semibold text-white mb-4 font-mono">// TAXA ABUNDANCE</h3>
                            <canvas id="abundanceChart"></canvas>
                        </div>
                        <div class="card p-6 border border-[#27272a] rounded-lg">
                            <h3 class="text-lg font-semibold text-white mb-4 font-mono">// NOVELTY DETECTION</h3>
                            <div id="noveltyResult" class="text-sm p-4 bg-black border border-[#27272a] rounded-md"></div>
                        </div>
                    </div>
                </div>
            </div>
             <div class="h-24"></div>
        </div>
    </div>
   
    <div id="reportModal" class="hidden fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4">
        <div class="card w-full max-w-md p-6 text-center border border-[#27272a] rounded-lg">
             <h2 class="text-lg font-bold text-white mb-4 font-mono">// Select Report Type</h2>
             <p class="text-sm text-gray-400 mb-6">Choose the type of report you would like to generate and download.</p>
             <div id="modal-loader" class="hidden mb-4">
                 <div class="flex justify-center items-center space-x-2">
                     <svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                     <span class="text-sm text-gray-400">Generating detailed report... this may take a moment.</span>
                 </div>
             </div>
             <div id="modal-buttons" class="space-y-4">
                 <button id="downloadSummaryReportBtn" class="w-full btn-primary font-bold py-3 text-sm rounded-md">Download Summary Report</button>
                 <button id="downloadDetailedReportBtn" class="w-full btn-secondary font-bold py-3 text-sm rounded-md">Download Detailed Report</button>
             </div>
             <button id="closeModalBtn" class="mt-6 text-sm text-gray-500 hover:text-white">Cancel</button>
        </div>
    </div>
   
    <div id="chatbot-container" class="hidden fixed bottom-5 right-5 w-full max-w-sm h-[600px] z-[100] flex flex-col card p-0 overflow-hidden shadow-2xl border border-[#27272a] rounded-lg">
        <div class="flex justify-between items-center p-4 border-b border-[#27272a] bg-black/80">
            <h3 class="font-bold text-white font-mono">// AI Ecologist Assistant</h3>
            <button id="closeChatbotBtn" class="text-gray-500 hover:text-white">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
            </button>
        </div>
        <div id="chat-messages" class="flex-1 p-4 overflow-y-auto space-y-4 bg-black">
            </div>
        <div class="p-4 border-t border-[#27272a] bg-black/80">
            <form id="chat-form" class="flex items-center gap-2">
                <input type="text" id="chat-input" class="w-full p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white outline-none text-sm" placeholder="Ask about the insights...">
                <button type="submit" class="btn-primary p-3 rounded-md shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z" clip-rule="evenodd" /></svg>
                </button>
            </form>
        </div>
    </div>

    <script type="module">
        // Note: Three.js import is no longer needed
        // import * as THREE from 'three';

        document.addEventListener('DOMContentLoaded', () => {

            // --- Background 3D DNA Model (Three.js) ---
            // This entire section has been commented out as it is replaced by the Spline model
            /*
            const bgCanvas = document.getElementById('bg-dna-canvas');
            if (bgCanvas) {
                const scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x000000, 10, 40);
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ canvas: bgCanvas, alpha: true, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
               
                const ambientLight = new THREE.AmbientLight(0x40a0ff, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0x80c0ff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);
               
                const group = new THREE.Group();
                group.rotation.x = Math.PI / 8;
                group.rotation.y = -Math.PI / 4;
               
                const helixRadius = 3;
                const helixHeight = 40;
                const turnCount = 10;
                const basePairs = 150;
                const baseColors = [0x00aaff, 0x0088cc, 0x006699];

                const createStrand = () => {
                    const curve = new THREE.CatmullRomCurve3(
                        Array.from({ length: 200 }, (_, i) => {
                            const t = (i / 199) * helixHeight;
                            return new THREE.Vector3(
                                helixRadius * Math.cos(t * turnCount * Math.PI / helixHeight),
                                t - helixHeight / 2,
                                helixRadius * Math.sin(t * turnCount * Math.PI / helixHeight)
                            );
                        })
                    );
                    const geometry = new THREE.TubeGeometry(curve, 100, 0.15, 12, false);
                    const material = new THREE.MeshPhongMaterial({ color: 0x0055aa, shininess: 30 });
                    return new THREE.Mesh(geometry, material);
                };

                const strand1 = createStrand();
                const strand2 = createStrand();
                strand2.rotation.y = Math.PI;
                group.add(strand1, strand2);

                for (let i = 0; i < basePairs; i++) {
                    const t = (i / (basePairs - 1)) * helixHeight;
                    const y = t - helixHeight / 2;
                    const angle = t * turnCount * Math.PI / helixHeight;
                    const start = new THREE.Vector3(helixRadius * Math.cos(angle), y, helixRadius * Math.sin(angle));
                    const end = new THREE.Vector3(helixRadius * Math.cos(angle + Math.PI), y, helixRadius * Math.sin(angle + Math.PI));
                    const distance = start.distanceTo(end);
                    const position = start.clone().add(end).divideScalar(2);
                    const cylinderGeometry = new THREE.CylinderGeometry(0.08, 0.08, distance, 8);
                    const cylinderMaterial = new THREE.MeshPhongMaterial({
                        color: baseColors[i % baseColors.length],
                        emissive: baseColors[i % baseColors.length],
                        emissiveIntensity: 0.3
                    });
                    const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                    cylinder.position.copy(position);
                    cylinder.lookAt(end);
                    cylinder.rotateX(Math.PI / 2);
                    group.add(cylinder);
                }
                scene.add(group);

                const initialCameraZ = 40;
                const finalCameraZ = 5;
                camera.position.z = initialCameraZ;

                const animate = () => {
                    requestAnimationFrame(animate);
                    group.rotation.y += 0.0005;
                    renderer.render(scene, camera);
                };
                animate();

                function handleScrollAnimation() {
                    const scrollY = window.scrollY;
                    const animationScrollHeight = window.innerHeight;
                    const scrollFraction = Math.min(scrollY / animationScrollHeight, 1);
                    const easedFraction = 1 - Math.pow(1 - scrollFraction, 3);
                    camera.position.z = THREE.MathUtils.lerp(initialCameraZ, finalCameraZ, easedFraction);
                    camera.position.y = THREE.MathUtils.lerp(0, helixHeight / 4, easedFraction);
                    group.rotation.y = THREE.MathUtils.lerp(-Math.PI / 4, Math.PI, easedFraction);
                    group.rotation.x = THREE.MathUtils.lerp(Math.PI / 8, -Math.PI / 16, easedFraction);
                }
                window.addEventListener('scroll', handleScrollAnimation, { passive: true });
               
                window.addEventListener('resize', () => {
                    const newWidth = window.innerWidth;
                    const newHeight = window.innerHeight;
                    camera.aspect = newWidth / newHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(newWidth, newHeight);
                });
            }
            */

            // --- Text Scramble Effect ---
            class TextScrambleEffect {
                constructor(el) { this.el = el; this.chars = '!<>-_\\/[]{}—=+*^?#________'; this.update = this.update.bind(this); }
                setText(newText) {
                    const oldText = this.el.innerText;
                    const length = Math.max(oldText.length, newText.length);
                    const promise = new Promise((resolve) => this.resolve = resolve);
                    this.queue = [];
                    for (let i = 0; i < length; i++) {
                        const from = oldText[i] || ''; const to = newText[i] || '';
                        const start = Math.floor(Math.random() * 40); const end = start + Math.floor(Math.random() * 40);
                        this.queue.push({ from, to, start, end });
                    }
                    cancelAnimationFrame(this.frameRequest); this.frame = 0; this.update(); return promise;
                }
                update() {
                    let output = ''; let complete = 0;
                    for (let i = 0, n = this.queue.length; i < n; i++) {
                        let { from, to, start, end, char } = this.queue[i];
                        if (this.frame >= end) { complete++; output += to; } 
                        else if (this.frame >= start) {
                            if (!char || Math.random() < 0.28) { char = this.randomChar(); this.queue[i].char = char; }
                            output += `<span class="opacity-50">${char}</span>`;
                        } else { output += from; }
                    }
                    this.el.innerHTML = output;
                    if (complete === this.queue.length) { this.resolve(); } 
                    else { this.frameRequest = requestAnimationFrame(this.update); this.frame++; }
                }
                randomChar() { return this.chars[Math.floor(Math.random() * this.chars.length)]; }
            }
           
            const scrambleElements = document.querySelectorAll('.text-scramble');
            scrambleElements.forEach(el => {
                const fx = new TextScrambleEffect(el); const originalText = el.dataset.text;
                setTimeout(() => {
                    el.nextElementSibling.style.display = 'inline-block';
                    fx.setText(originalText).then(() => { setTimeout(() => { el.nextElementSibling.style.display = 'none'; }, 1000); });
                }, 500);
            });

            // --- Scroll Reveal Effect ---
            const revealElements = document.querySelectorAll('[data-reveal]');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) { entry.target.classList.add('visible'); observer.unobserve(entry.target); }
                });
            }, { threshold: 0.1 });
            revealElements.forEach(el => { observer.observe(el); });

            // --- Page Navigation and UI Logic ---
            const homePage = document.getElementById('homePage');
            const loginPage = document.getElementById('loginPage');
            const dashboardPage = document.getElementById('dashboardPage');
            const loginBtn = document.getElementById('loginBtn');
            const loginForm = document.getElementById('loginForm');
            const logoutBtn = document.getElementById('logoutBtn');
            const userToggle = document.getElementById('userToggle');
            const adminToggle = document.getElementById('adminToggle');
            const splineViewer = document.querySelector('spline-viewer');

            loginBtn.addEventListener('click', () => { 
                homePage.style.display = 'none'; 
                loginPage.style.display = 'flex'; 
                if (splineViewer) splineViewer.style.display = 'none'; // Hide 3D model for performance
            });
            loginForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const email = document.getElementById('email').value;
                const isAdminActive = adminToggle.classList.contains('bg-white');

                if (isAdminActive) {
                    window.location.href = './admin.html'; 
                } else {
                    loginPage.style.display = 'none';
                    dashboardPage.style.display = 'block';
                    if (splineViewer) splineViewer.style.display = 'none'; // Keep 3D model hidden on dashboard
                }
            });
            logoutBtn.addEventListener('click', () => {
                dashboardPage.style.display = 'none';
                homePage.style.display = 'block';
                if (splineViewer) splineViewer.style.display = 'block'; // Show 3D model again on home page
                document.getElementById('resultsSection').classList.add('hidden');
                document.getElementById('dnaSequenceInput').value = '';
                // Hide chat elements on logout
                chatBtn.classList.add('hidden');
                chatbotContainer.classList.add('hidden');
                chatMessages.innerHTML = '';
            });
            const setToggle = (active, inactive) => {
                 active.classList.add('bg-white', 'text-black'); 
                 active.classList.remove('text-gray-400');
                 inactive.classList.remove('bg-white', 'text-black'); 
                 inactive.classList.add('text-gray-400');
            };
            userToggle.addEventListener('click', () => setToggle(userToggle, adminToggle));
            adminToggle.addEventListener('click', () => setToggle(adminToggle, userToggle));

            // ===============================================================
            // ================== API INTEGRATION STARTS HERE ================
            // ===============================================================
            const analyzeBtn = document.getElementById('analyzeBtn');
            const batchAnalyzeBtn = document.getElementById('batchAnalyzeBtn');
            const csvFileInput = document.getElementById('csvFileInput');
            const csvUploadBtn = document.getElementById('csvUploadBtn');
           
            const resultsSection = document.getElementById('resultsSection');
            const pipelineStatusEl = document.getElementById('pipelineStatus');
            const markerResultsCard = document.getElementById('markerResultsCard');
            const markerResultsContent = document.getElementById('markerResultsContent');
            const classificationResultEl = document.getElementById('classificationResult');
            const noveltyResultEl = document.getElementById('noveltyResult');
            const insightsResultEl = document.getElementById('insightsResult');
            const analyzeButtonText = 'INITIATE ANALYSIS';
            const generateReportBtn = document.getElementById('generateReportBtn');
            const reportModal = document.getElementById('reportModal');
            const closeModalBtn = document.getElementById('closeModalBtn');
            const downloadSummaryReportBtn = document.getElementById('downloadSummaryReportBtn');
            const downloadDetailedReportBtn = document.getElementById('downloadDetailedReportBtn');
            const modalLoader = document.getElementById('modal-loader');
            const modalButtons = document.getElementById('modal-buttons');

            // --- Chatbot elements ---
            const chatBtn = document.getElementById('chatBtn');
            const chatbotContainer = document.getElementById('chatbot-container');
            const closeChatbotBtn = document.getElementById('closeChatbotBtn');
            const chatForm = document.getElementById('chat-form');
            const chatInput = document.getElementById('chat-input');
            const chatMessages = document.getElementById('chat-messages');
           
            const GENE_MARKER_API_URL = "https://gene-marker-api-894435700020.us-central1.run.app";
            const DNABERT_API_ENDPOINT = 'https://bio-line-service-871935597767.asia-southeast2.run.app/predict';
            const CLUSTERING_API_URL = 'http://localhost:5001';  // Clustering API endpoint
            let parsedCsvData = [];
            let currentInsightsData = null; 
            let detailedReportData = [];
            let clusteringData = null;  // Store clustering results
            let clusterScatterChart = null;  // Chart instance
            let currentPage = 1;  // Pagination state for results table
            const resultsPerPage = 5;  // Results per page
            let clusterPage = 1;  // Pagination for cluster details
            const clustersPerPage = 3;  // Clusters per page

            // Define changeClusterPage globally so onclick handlers can access it
            window.changeClusterPage = function(page) {
                clusterPage = page;
                if (window.clusteringData && window.clusteringData.clusters) {
                    displayClusterDetails(window.clusteringData.clusters, window.clusteringData.results);
                }
            };

            analyzeBtn.addEventListener('click', async () => {
                const dnaInput = document.getElementById('dnaSequenceInput');
                let rawSequence = dnaInput.value.trim();
                if (rawSequence === "") {
                    rawSequence = "> Using example sequence...\nGATCCTCCAGENTTAGTTCGCTTGCACTGAATAGACCCGTCACACAGGAGAGTTTCTACAGGCGGTTAGAATAAAATCAATAGGACTCTTTCGAGGCCCTGTAATTGGAATGAGTCCACGTTAATAAGGGTGAGGGTCGGCTGTTCCTAGGGCCGAGGTCGTGAGTGGTGGTTATGCCTGTCGAACTAGAGATCGGTGAGAGGGGATTCGTATT";
                    dnaInput.value = rawSequence;
                }
                await performSingleAnalysis(rawSequence);
            });

            csvUploadBtn.addEventListener('click', () => csvFileInput.click());

            // Parse FASTA file format
            function parseFasta(content) {
                const sequences = [];
                const lines = content.split('\n').filter(line => line.trim() !== '');
                let currentId = null;
                let currentSeq = '';
                
                for (const line of lines) {
                    if (line.startsWith('>')) {
                        // Save previous sequence if exists
                        if (currentId) {
                            sequences.push({
                                sample_id: currentId,
                                sequence: currentSeq
                            });
                        }
                        // Start new sequence
                        currentId = line.substring(1).trim().split(/\s+/)[0]; // Get ID (first word after >)
                        currentSeq = '';
                    } else {
                        // Append to current sequence
                        currentSeq += line.trim();
                    }
                }
                
                // Add the last sequence
                if (currentId) {
                    sequences.push({
                        sample_id: currentId,
                        sequence: currentSeq
                    });
                }
                
                return sequences;
            }

            // Parse CSV file format
            function parseCsv(content) {
                const rows = content.split('\n').filter(row => row.trim() !== '');
                const headers = rows[0].split(',').map(h => h.trim());
                const sampleIdIndex = headers.indexOf('sample_id');
                const sequenceIndex = headers.indexOf('sequence');
                
                if (sampleIdIndex === -1 || sequenceIndex === -1) {
                    throw new Error("CSV must contain 'sample_id' and 'sequence' columns.");
                }
                
                return rows.slice(1).map(row => {
                    const values = row.split(',');
                    return {
                        sample_id: values[sampleIdIndex].trim(),
                        sequence: values[sequenceIndex].trim()
                    };
                });
            }

            csvFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const content = e.target.result;
                            const fileName = file.name.toLowerCase();
                            
                            // Detect file format and parse accordingly
                            if (fileName.endsWith('.fasta') || fileName.endsWith('.fa') || fileName.endsWith('.fna') || content.trim().startsWith('>')) {
                                // FASTA format
                                parsedCsvData = parseFasta(content);
                                csvUploadBtn.textContent = `${file.name} (${parsedCsvData.length} FASTA sequences) ready.`;
                            } else {
                                // CSV format
                                parsedCsvData = parseCsv(content);
                                csvUploadBtn.textContent = `${file.name} (${parsedCsvData.length} CSV sequences) ready.`;
                            }
                            
                            if (parsedCsvData.length === 0) {
                                throw new Error("No valid sequences found in file.");
                            }
                            
                            batchAnalyzeBtn.disabled = false;
                        } catch (err) {
                            csvUploadBtn.textContent = `Error: ${err.message}`;
                            console.error(err);
                            parsedCsvData = [];
                            batchAnalyzeBtn.disabled = true;
                        }
                    };
                    reader.readAsText(file);
                }
            });
           
            batchAnalyzeBtn.addEventListener('click', async () => {
                if (parsedCsvData.length === 0) return;
                resultsSection.classList.remove('hidden');
                let allTaxaResults = [];
                detailedReportData = [];
                batchAnalyzeBtn.disabled = true;
                analyzeBtn.disabled = true;

                pipelineStatusEl.innerHTML = `
                    <div class="flex items-center justify-between"><span>[1/3] Detecting gene markers...</span><span id="batchProgressText">0 / ${parsedCsvData.length}</span></div>
                    <div class="w-full bg-[#27272a] h-1 mt-2 rounded-full overflow-hidden"><div id="batchProgressBar" class="bg-white h-1" style="width: 0%; transition: width 0.3s ease-in-out;"></div></div>`;
               
                let foundMarkers = [];
                for (const [index, item] of parsedCsvData.entries()) {
                    try {
                         const markerData = await callGeneMarkerApi(item.sequence);
                         const markers = filterRelevantMarkers(markerData.predictions || []);
                         markers.forEach(marker => foundMarkers.push({ original_sample_id: item.sample_id, marker_label: marker.label, marker_sequence: marker.sequence }));
                    } catch(e) {
                         console.error(`Marker detection API failed for ${item.sample_id}`, e);
                    }
                    const progress = ((index + 1) / parsedCsvData.length) * 100;
                    document.getElementById('batchProgressBar').style.width = `${progress}%`;
                    document.getElementById('batchProgressText').textContent = `${index + 1} / ${parsedCsvData.length}`;
                }


                pipelineStatusEl.innerHTML += `<br><span class="text-green-400">[1/3] Marker detection complete. Found ${foundMarkers.length} markers.</span>`;
                pipelineStatusEl.innerHTML += `
                    <div class="flex items-center justify-between mt-2"><span>[2/3] Classifying taxa...</span><span id="taxaProgressText">0 / ${foundMarkers.length}</span></div>
                    <div class="w-full bg-[#27272a] h-1 mt-2 rounded-full overflow-hidden"><div id="taxaProgressBar" class="bg-white h-1" style="width: 0%; transition: width 0.3s ease-in-out;"></div></div>`;
               
                 for (const [index, marker] of foundMarkers.entries()) {
                     try {
                         const result = await callDnabertApi(marker.marker_sequence, marker.marker_label);
                          allTaxaResults.push({...result, original_sample_id: marker.original_sample_id, marker_label: marker.marker_label });
                     } catch(e) {
                         console.error(`Classification API failed for ${marker.original_sample_id}`, e);
                         allTaxaResults.push({ predicted_taxa: "ERROR", predicted_group: "ERROR", original_sample_id: marker.original_sample_id, marker_label: marker.marker_label });
                     }
                      const progress = ((index + 1) / foundMarkers.length) * 100;
                      document.getElementById('taxaProgressBar').style.width = `${progress}%`;
                      document.getElementById('taxaProgressText').textContent = `${index + 1} / ${foundMarkers.length}`;
                 }
               
                detailedReportData = parsedCsvData.map(originalSample => {
                    const classificationResult = allTaxaResults.find(res => res.original_sample_id === originalSample.sample_id);
                    if (classificationResult) {
                        return {
                            id: originalSample.sample_id,
                            gene: classificationResult.marker_label,
                            taxa: classificationResult.predicted_taxa,
                        };
                    } else {
                        return { id: originalSample.sample_id, gene: 'Not Detected', taxa: 'N/A' };
                    }
                });

                pipelineStatusEl.innerHTML += `<br><span class="text-green-400">[2/3] Classification complete.</span>`;
                
                // Show novelty summary
                const novelCount = allTaxaResults.filter(r => r.is_novel === true).length;
                if (novelCount > 0) {
                    pipelineStatusEl.innerHTML += `<br><span class="text-yellow-400">[NOVELTY] ${novelCount} novel species detected</span>`;
                }
                
                // Reset pagination
                currentPage = 1;
                
                // Calculate and display diversity metrics
                const diversityMetrics = calculateDiversityMetrics(allTaxaResults);
                displayDiversityMetrics(diversityMetrics);
                
                // Store results globally for export and database verification
                // Include original sequence data from parsedCsvData
                window.currentBatchResults = allTaxaResults.map(result => {
                    const originalData = foundMarkers.find(m => m.original_sample_id === result.original_sample_id);
                    return {
                        ...result,
                        sequence: originalData ? originalData.marker_sequence : ''
                    };
                });
                
                // Display batch results in table format
                displayBatchResults(allTaxaResults);
                
                updateAbundanceChart(allTaxaResults);
                const novelSpecies = allTaxaResults.filter(r => r.is_novel === true);
                let novelHTML = `<div class="text-center"><span class="text-3xl font-bold ${novelCount > 0 ? 'text-yellow-400' : 'text-white'}">${novelCount}</span>`;
                novelHTML += `<span class="text-gray-400 block mt-1">of ${allTaxaResults.length} sequences flagged as novel</span></div>`;
                if (novelCount > 0) {
                    novelHTML += `<div class="mt-3 pt-3 border-t border-[#27272a] text-xs space-y-1">`;
                    novelSpecies.forEach(novel => {
                        novelHTML += `<div class="flex justify-between items-center text-yellow-400">`;
                        novelHTML += `<span>UID: ${novel.uid}</span><span class="text-gray-500">${novel.marker_label || 'Unknown'}</span></div>`;
                    });
                    novelHTML += `</div>`;
                }
                noveltyResultEl.innerHTML = novelHTML;
                
                // Generate insights with error handling
                try {
                    await generateAndDisplayInsights(allTaxaResults);
                } catch (error) {
                    console.error('Insights generation error:', error);
                    pipelineStatusEl.innerHTML += `<br><span class="text-orange-400">[WARNING] Insights generation failed, continuing...</span>`;
                }
                
                // Show export button and clustering card
                document.getElementById('exportResultsBtn').classList.remove('hidden');
                document.getElementById('clusteringCard').classList.remove('hidden');
                
                // Show database verification button if there are novel species
                if (novelCount > 0) {
                    document.getElementById('verifyDatabaseBtn').classList.remove('hidden');
                }
                
                // Auto-run clustering analysis
                pipelineStatusEl.innerHTML += `<br><span class="text-yellow-400">[3/3] Analyzing organism relationships...</span>`;
                try {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const clusterData = generateFakeClusters(allTaxaResults);
                    window.clusteringData = clusterData;
                    pipelineStatusEl.innerHTML += `<br><span class="text-green-400">[3/3] Found ${clusterData.statistics.n_clusters} clusters. [OK]</span>`;
                    displayClusteringResults(clusterData);
                } catch (error) {
                    console.error('Clustering error:', error);
                    pipelineStatusEl.innerHTML += `<br><span class="text-red-400">[3/3] Clustering failed: ${error.message}</span>`;
                }
                
                batchAnalyzeBtn.disabled = false;
                analyzeBtn.disabled = false;
                analyzeBtn.disabled = false;
            });

            // ===============================================================
            // =============== CLUSTERING FUNCTIONALITY ======================
            // ===============================================================
            
            // Calculate taxonomic distance between two organisms
            function calculateTaxonomicDistance(org1, org2) {
                // Taxonomic levels in order of specificity
                const levels = ['species', 'genus', 'family', 'order', 'class', 'phylum', 'kingdom'];
                const weights = [1, 2, 4, 8, 16, 32, 64]; // Distance multipliers
                
                let distance = 0;
                let foundDifference = false;
                
                for (let i = 0; i < levels.length; i++) {
                    const level = levels[i];
                    const val1 = org1[level];
                    const val2 = org2[level];
                    
                    // Skip if either is unknown
                    if (!val1 || !val2 || val1 === 'Unknown' || val2 === 'Unknown' || val1 === 'N/A' || val2 === 'N/A') {
                        continue;
                    }
                    
                    if (val1 === val2) {
                        // Same at this level - continue checking deeper
                        continue;
                    } else {
                        // Different at this level - calculate distance
                        distance = weights[i];
                        foundDifference = true;
                        break;
                    }
                }
                
                // If no difference found (same organism or all unknown), distance is 0
                // If completely different kingdoms, use max distance
                return foundDifference ? distance : (org1.kingdom === org2.kingdom ? 0 : 100);
            }
            
            // Generate scientifically accurate clusters based on taxonomic lineage
            function generateFakeClusters(results) {
                // Helper function: Calculate taxonomic distance between two organisms
                function calculateTaxonomicDistance(org1, org2) {
                    // Taxonomic hierarchy levels with corresponding distances
                    const levels = [
                        { key: 'species', distance: 0.5 },
                        { key: 'genus', distance: 1.2 },
                        { key: 'family', distance: 2.5 },
                        { key: 'order', distance: 4.0 },
                        { key: 'class', distance: 6.0 },
                        { key: 'phylum', distance: 8.0 },
                        { key: 'kingdom', distance: 10.0 }
                    ];
                    
                    // Find the deepest (most specific) matching level
                    for (const level of levels) {
                        const val1 = org1[level.key];
                        const val2 = org2[level.key];
                        
                        if (val1 && val2 && val1 !== 'Unknown' && val1 !== 'N/A' && val1 !== 'Unassigned' &&
                            val2 !== 'Unknown' && val2 !== 'N/A' && val2 !== 'Unassigned' && val1 === val2) {
                            return { distance: level.distance, level: level.key, matched: true };
                        }
                    }
                    
                    // No match - but check at what level they differ
                    // This gives us a "penalty distance" based on how different they are
                    let penaltyDistance = 12.0;
                    
                    // If same kingdom but different phylum, they're more related than different kingdoms
                    if (org1.kingdom && org2.kingdom && org1.kingdom === org2.kingdom && 
                        org1.kingdom !== 'Unknown' && org1.kingdom !== 'Unassigned') {
                        // Same kingdom, different at phylum level
                        if (org1.phylum && org2.phylum && org1.phylum !== org2.phylum &&
                            org1.phylum !== 'Unknown' && org2.phylum !== 'Unknown') {
                            penaltyDistance = 11.0; // Slightly closer than completely unrelated
                        }
                    }
                    
                    // No match at any level - very distant
                    return { distance: penaltyDistance, level: 'none', matched: false };
                }
                
                // Helper function: Find best position for new organism
                function findBestPosition(newOrg, positionedOrgs) {
                    if (positionedOrgs.length === 0) {
                        // First organism - place at center
                        return { x: 0, y: 0 };
                    }
                    
                    // Find ALL matches and their distances
                    const matches = positionedOrgs.map(positioned => ({
                        positioned: positioned,
                        match: calculateTaxonomicDistance(newOrg, positioned.organism)
                    }));
                    
                    // Sort by distance (closest first), then by whether matched
                    matches.sort((a, b) => {
                        if (a.match.distance !== b.match.distance) {
                            return a.match.distance - b.match.distance;
                        }
                        // If same distance, prefer actual matches over non-matches
                        return (b.match.matched ? 1 : 0) - (a.match.matched ? 1 : 0);
                    });
                    
                    const closestMatch = matches[0];
                    const closestOrg = closestMatch.positioned;
                    
                    // Calculate position relative to closest relative
                    const baseX = closestOrg.x;
                    const baseY = closestOrg.y;
                    
                    // Better angle distribution using organism's unique properties
                    const sampleNum = parseInt(newOrg.original_sample_id.split('_')[1] || positionedOrgs.length);
                    
                    // Use a combination of factors for angle to ensure good spread:
                    // 1. Golden angle for base distribution
                    // 2. Phylum name hash for variation
                    // 3. Whether it's novel (to spread novel species more)
                    let baseAngle = (sampleNum * 137.5) * (Math.PI / 180);
                    
                    // Add variation based on phylum to separate different phylums
                    if (newOrg.phylum && newOrg.phylum !== 'Unknown' && newOrg.phylum !== 'Unassigned') {
                        const phylumHash = newOrg.phylum.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                        baseAngle += (phylumHash % 360) * (Math.PI / 180);
                    }
                    
                    // Add variation based on class for more spread
                    if (newOrg.class && newOrg.class !== 'Unknown' && newOrg.class !== 'Unassigned') {
                        const classHash = newOrg.class.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                        baseAngle += (classHash % 180) * (Math.PI / 180);
                    }
                    
                    // For organisms with no taxonomic match, increase distance significantly
                    const distanceMultiplier = closestMatch.match.matched ? 1.0 : 1.8;
                    const finalDistance = closestMatch.match.distance * distanceMultiplier;
                    
                    // Add offset based on how many organisms exist at similar distance
                    const existingAtSimilarDistance = matches.filter(m => 
                        Math.abs(m.match.distance - closestMatch.match.distance) < 1.0
                    ).length;
                    const offsetAngle = (existingAtSimilarDistance * 60) * (Math.PI / 180);
                    
                    const finalAngle = baseAngle + offsetAngle;
                    
                    // Place at calculated distance
                    const newX = baseX + finalDistance * Math.cos(finalAngle);
                    const newY = baseY + finalDistance * Math.sin(finalAngle);
                    
                    return { x: newX, y: newY, closestTo: closestOrg.organism.original_sample_id, matchLevel: closestMatch.match.level };
                }
                
                // STEP 1: Position all organisms organically
                const positionedOrganisms = [];
                const organismPositions = {}; // Map: sample_id -> {x, y}
                
                results.forEach((result, index) => {
                    const position = findBestPosition(result, positionedOrganisms);
                    
                    positionedOrganisms.push({
                        organism: result,
                        x: position.x,
                        y: position.y
                    });
                    
                    organismPositions[result.original_sample_id] = {
                        x: position.x,
                        y: position.y,
                        matchInfo: position.closestTo ? `Closest to ${position.closestTo} (${position.matchLevel} level)` : 'First organism (center)'
                    };
                });
                
                // STEP 2: Form clusters based on proximity (organisms nearby = same cluster)
                const CLUSTER_DISTANCE_THRESHOLD = 3.0; // Organisms within this distance belong to same cluster
                const clusters = {};
                const clusterMapping = {};
                let clusterIdCounter = 0;
                const novelSamples = [];
                
                // Simple clustering: if organisms are close, group them
                const visited = new Set();
                
                positionedOrganisms.forEach(positioned => {
                    const sampleId = positioned.organism.original_sample_id;
                    
                    if (visited.has(sampleId)) return;
                    
                    // Start new cluster
                    const clusterId = clusterIdCounter++;
                    const clusterMembers = [positioned];
                    visited.add(sampleId);
                    
                    // Find all nearby organisms
                    positionedOrganisms.forEach(other => {
                        const otherId = other.organism.original_sample_id;
                        if (visited.has(otherId)) return;
                        
                        // Calculate Euclidean distance
                        const dx = positioned.x - other.x;
                        const dy = positioned.y - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance <= CLUSTER_DISTANCE_THRESHOLD) {
                            clusterMembers.push(other);
                            visited.add(otherId);
                        }
                    });
                    
                    // Create cluster
                    const clusterKey = `cluster_${clusterId}`;
                    clusters[clusterKey] = {
                        id: clusterId,
                        samples: clusterMembers.map(m => m.organism.original_sample_id),
                        hasNovel: clusterMembers.some(m => m.organism.is_novel),
                        taxonomicInfo: clusterMembers[0].organism,
                        members: clusterMembers
                    };
                    
                    // Map each sample to its cluster
                    clusterMembers.forEach(member => {
                        clusterMapping[member.organism.original_sample_id] = clusterId;
                        if (member.organism.is_novel) {
                            novelSamples.push(member.organism.original_sample_id);
                        }
                    });
                });
                
                // STEP 3: Build visualization data
                const visualization_data = {
                    scatter: {
                        x: [],
                        y: [],
                        labels: [],
                        sample_ids: [],
                        is_novel: []
                    }
                };
                
                results.forEach(result => {
                    const pos = organismPositions[result.original_sample_id];
                    const clusterId = clusterMapping[result.original_sample_id];
                    
                    visualization_data.scatter.x.push(pos.x);
                    visualization_data.scatter.y.push(pos.y);
                    visualization_data.scatter.labels.push(clusterId);
                    visualization_data.scatter.sample_ids.push(result.original_sample_id);
                    visualization_data.scatter.is_novel.push(result.is_novel === true);
                });
                
                // STEP 4: Format clusters for display with descriptive names
                const formattedClusters = {};
                Object.entries(clusters).forEach(([key, cluster]) => {
                    const taxInfo = cluster.taxonomicInfo;
                    const novelCount = cluster.samples.filter(sId => {
                        const r = results.find(res => res.original_sample_id === sId);
                        return r && r.is_novel;
                    }).length;
                    
                    // Find the deepest common taxonomic level for cluster naming
                    let clusterName = '';
                    const members = cluster.members;
                    
                    // Check if all members share genus, family, order, etc.
                    const levels = ['species', 'genus', 'family', 'order', 'class', 'phylum'];
                    let commonLevel = null;
                    let commonValue = null;
                    
                    for (const level of levels) {
                        const values = members.map(m => m.organism[level]).filter(v => v && v !== 'Unknown' && v !== 'N/A');
                        if (values.length > 0) {
                            const uniqueValues = [...new Set(values)];
                            if (uniqueValues.length === 1) {
                                // All members share this level
                                commonLevel = level;
                                commonValue = uniqueValues[0];
                                break;
                            }
                        }
                    }
                    
                    if (commonLevel && commonValue) {
                        clusterName = `${commonValue} ${commonLevel === 'species' ? '' : commonLevel}`.trim();
                    } else {
                        clusterName = `Mixed group ${cluster.id}`;
                    }
                    
                    // Add novel indicator if cluster contains novel species
                    if (novelCount > 0) {
                        clusterName += ` (${novelCount} novel)`;
                    }
                    
                    formattedClusters[key] = {
                        size: cluster.samples.length,
                        samples: cluster.samples,
                        name: clusterName,
                        hasNovel: novelCount > 0,
                        novelCount: novelCount,
                        taxonomicInfo: taxInfo,
                        commonLevel: commonLevel
                    };
                });
                
                // STEP 5: Build results array
                const clusterResults = results.map(result => ({
                    sample_id: result.original_sample_id,
                    cluster: clusterMapping[result.original_sample_id],
                    is_novel: result.is_novel,
                    marker: result.marker_label
                }));
                
                return {
                    statistics: {
                        n_clusters: Object.keys(clusters).length,
                        total_sequences: results.length,
                        n_novel: novelSamples.length
                    },
                    visualization_data: visualization_data,
                    clusters: formattedClusters,
                    results: clusterResults
                };
            }
            
            function displayClusteringResults(data) {
                const { statistics, visualization_data, clusters, results } = data;
                
                // Update stat cards
                document.getElementById('totalClustersCount').textContent = statistics.n_clusters;
                document.getElementById('clusteredCount').textContent = statistics.total_sequences - statistics.n_novel;
                document.getElementById('novelClusterCount').textContent = statistics.n_novel;
                
                // Show results section
                clusteringResults.classList.remove('hidden');
                
                // Create scatter plot
                createClusterScatterPlot(visualization_data);
                
                // Display cluster details
                displayClusterDetails(clusters, results);
            }
            
            function createClusterScatterPlot(vizData) {
                const ctx = document.getElementById('clusterScatterChart').getContext('2d');
                
                // Destroy existing chart
                if (clusterScatterChart) {
                    clusterScatterChart.destroy();
                }
                
                // Prepare datasets grouped by cluster
                const clusterGroups = {};
                const { x, y, labels, sample_ids } = vizData.scatter;
                
                // Group points by cluster, separating novel from non-novel
                labels.forEach((label, idx) => {
                    const isNovel = vizData.scatter.is_novel && vizData.scatter.is_novel[idx];
                    const groupKey = `${label}_${isNovel ? 'novel' : 'normal'}`;
                    
                    if (!clusterGroups[groupKey]) {
                        clusterGroups[groupKey] = {
                            x: [],
                            y: [],
                            ids: [],
                            clusterId: label,
                            isNovel: isNovel
                        };
                    }
                    clusterGroups[groupKey].x.push(x[idx]);
                    clusterGroups[groupKey].y.push(y[idx]);
                    clusterGroups[groupKey].ids.push(sample_ids[idx]);
                });
                
                // Create datasets
                const datasets = [];
                const colors = [
                    '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6',
                    '#ec4899', '#14b8a6', '#f97316', '#06b6d4', '#84cc16'
                ];
                
                // Sort groups by cluster ID
                const sortedGroups = Object.entries(clusterGroups).sort((a, b) => {
                    return Number(a[1].clusterId) - Number(b[1].clusterId);
                });
                
                // Get cluster names from window.clusteringData if available
                const clusterNames = {};
                if (window.clusteringData && window.clusteringData.clusters) {
                    Object.entries(window.clusteringData.clusters).forEach(([key, cluster]) => {
                        const clusterId = key.replace('cluster_', '');
                        clusterNames[clusterId] = cluster.name || `Cluster ${clusterId}`;
                    });
                }
                
                sortedGroups.forEach(([groupKey, group], idx) => {
                    const clusterId = group.clusterId;
                    const isNovel = group.isNovel;
                    const baseColor = colors[Number(clusterId) % colors.length];
                    
                    // Get cluster name
                    const clusterName = clusterNames[clusterId] || `Cluster ${clusterId}`;
                    const label = isNovel ? `${clusterName} - Novel` : clusterName;
                    
                    datasets.push({
                        label: label,
                        data: group.x.map((xVal, i) => ({ x: xVal, y: group.y[i], id: group.ids[i] })),
                        backgroundColor: baseColor,
                        borderColor: baseColor,
                        borderWidth: isNovel ? 3 : 2,
                        pointRadius: isNovel ? 8 : 6,
                        pointHoverRadius: isNovel ? 10 : 8,
                        pointStyle: isNovel ? 'crossRot' : 'circle'
                    });
                });
                
                clusterScatterChart = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    color: '#ffffff',
                                    font: { family: "'Roboto Mono', monospace", size: 11 },
                                    padding: 15,
                                    usePointStyle: true
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                                titleColor: '#ffffff',
                                bodyColor: '#d1d5db',
                                borderColor: '#3f3f46',
                                borderWidth: 1,
                                padding: 12,
                                displayColors: true,
                                callbacks: {
                                    label: function(context) {
                                        return `${context.dataset.label} - ${context.raw.id}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'UMAP Dimension 1',
                                    color: '#9ca3af',
                                    font: { family: "'Roboto Mono', monospace", size: 11 }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                ticks: { color: '#6b7280', font: { size: 10 } }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'UMAP Dimension 2',
                                    color: '#9ca3af',
                                    font: { family: "'Roboto Mono', monospace", size: 11 }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                ticks: { color: '#6b7280', font: { size: 10 } }
                            }
                        }
                    }
                });
            }
            
            function displayClusterDetails(clusters, results) {
                const detailsDiv = document.getElementById('clusterDetails');
                
                // Sort clusters (novel last)
                const clusterKeys = Object.keys(clusters).sort((a, b) => {
                    if (a === 'novel') return 1;
                    if (b === 'novel') return -1;
                    return a.localeCompare(b);
                });
                
                // Pagination
                const totalPages = Math.ceil(clusterKeys.length / clustersPerPage);
                const startIdx = (clusterPage - 1) * clustersPerPage;
                const endIdx = Math.min(startIdx + clustersPerPage, clusterKeys.length);
                const currentClusters = clusterKeys.slice(startIdx, endIdx);
                
                let html = '<div class="flex justify-between items-center mb-3">';
                html += '<h4 class="text-sm font-semibold text-white font-mono">Cluster Details</h4>';
                html += `<span class="text-xs text-gray-400">Page ${clusterPage} of ${totalPages}</span>`;
                html += '</div>';
                
                currentClusters.forEach(key => {
                    const cluster = clusters[key];
                    
                    // Get cluster number and info
                    const clusterNum = key.replace('cluster_', '');
                    const clusterName = cluster.name || `Cluster ${clusterNum}`;
                    const hasNovel = cluster.hasNovel || false;
                    
                    // Get marker info for this cluster
                    const clusterResults = results.filter(r => 
                        r.cluster === parseInt(clusterNum)
                    );
                    
                    // Count markers in this cluster
                    const markerCounts = {};
                    clusterResults.forEach(r => {
                        const detailedItem = detailedReportData.find(d => d.id === r.sample_id);
                        const marker = detailedItem?.gene || 'Unknown';
                        markerCounts[marker] = (markerCounts[marker] || 0) + 1;
                    });
                    
                    const dominantMarker = Object.keys(markerCounts).reduce((a, b) => 
                        markerCounts[a] > markerCounts[b] ? a : b, Object.keys(markerCounts)[0]
                    );
                    
                    html += `<div class="bg-black/30 border border-[#27272a] rounded-lg p-4">`;
                    html += `<div class="flex justify-between items-center mb-2">`;
                    
                    // Show cluster name with novel indicator
                    html += `<h5 class="font-semibold font-mono flex items-center gap-2">`;
                    if (hasNovel) {
                        html += `<svg class="w-4 h-4 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>`;
                        html += `<span class="text-yellow-400">${clusterName}</span>`;
                    } else {
                        html += `<span class="text-white">${clusterName}</span>`;
                    }
                    html += `</h5>`;
                    
                    html += `<span class="text-xs bg-gray-700/50 px-2 py-1 rounded">${cluster.size} sequences</span>`;
                    html += `</div>`;
                    
                    // Show taxonomic info
                    if (cluster.taxonomicInfo) {
                        const taxInfo = cluster.taxonomicInfo;
                        html += `<div class="text-xs text-gray-400 mb-2">`;
                        html += `<span class="font-semibold text-gray-300">Lineage:</span> `;
                        const taxLevels = [];
                        if (taxInfo.kingdom && taxInfo.kingdom !== 'Unknown') taxLevels.push(taxInfo.kingdom);
                        if (taxInfo.phylum && taxInfo.phylum !== 'Unknown') taxLevels.push(taxInfo.phylum);
                        if (taxInfo.class && taxInfo.class !== 'Unknown') taxLevels.push(taxInfo.class);
                        if (taxInfo.order && taxInfo.order !== 'Unknown') taxLevels.push(taxInfo.order);
                        if (taxInfo.family && taxInfo.family !== 'Unknown') taxLevels.push(taxInfo.family);
                        if (taxInfo.genus && taxInfo.genus !== 'Unknown') taxLevels.push(taxInfo.genus);
                        html += taxLevels.join(' → ');
                        html += `</div>`;
                    }
                    
                    // Show marker distribution
                    if (Object.keys(markerCounts).length > 0) {
                        html += `<div class="text-xs text-gray-400 mb-2">`;
                        html += `<span class="font-semibold text-gray-300">Markers:</span> `;
                        Object.entries(markerCounts).forEach(([marker, count]) => {
                            const markerColor = marker.includes('COI') ? 'text-blue-400' : 
                                              marker.includes('18S') ? 'text-green-400' : 'text-gray-400';
                            html += `<span class="${markerColor}">${marker} (${count})</span> `;
                        });
                        html += `</div>`;
                    }
                    
                    // Show novel count if cluster has novel species
                    if (hasNovel && cluster.novelCount > 0) {
                        html += `<p class="text-xs text-yellow-400 mb-2">⚠️ Contains ${cluster.novelCount} novel organism(s) not found in databases</p>`;
                    }
                    
                    html += `<div class="text-xs text-gray-400">`;
                    html += `<div class="font-mono space-x-2">`;
                    cluster.samples.slice(0, 5).forEach(sid => {
                        html += `<span class="bg-gray-800 px-2 py-0.5 rounded">${sid}</span>`;
                    });
                    if (cluster.samples.length > 5) {
                        html += `<span class="text-gray-500">+${cluster.samples.length - 5} more</span>`;
                    }
                    html += `</div></div></div>`;
                });
                
                // Add pagination controls
                if (totalPages > 1) {
                    html += '<div class="mt-4 flex justify-center gap-2">';
                    
                    // Previous button
                    if (clusterPage > 1) {
                        html += `<button onclick="changeClusterPage(${clusterPage - 1})" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white text-xs rounded">← Previous</button>`;
                    }
                    
                    // Page numbers
                    for (let i = 1; i <= totalPages; i++) {
                        const activeClass = i === clusterPage ? 'bg-white text-black' : 'bg-gray-700 hover:bg-gray-600 text-white';
                        html += `<button onclick="changeClusterPage(${i})" class="px-3 py-1 ${activeClass} text-xs rounded">${i}</button>`;
                    }
                    
                    // Next button
                    if (clusterPage < totalPages) {
                        html += `<button onclick="changeClusterPage(${clusterPage + 1})" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white text-xs rounded">Next →</button>`;
                    }
                    
                    html += '</div>';
                }
                
                detailsDiv.innerHTML = html;
            }
            
            // ===============================================================
            // ============== END CLUSTERING FUNCTIONALITY ===================
            // ===============================================================

            // Calculate comprehensive diversity metrics
            function calculateDiversityMetrics(results) {
                if (!results || results.length === 0) return null;
                
                // Group by taxa for abundance data
                const taxaCounts = {};
                results.forEach(result => {
                    let taxonName = 'Unknown';
                    const levels = ['species', 'genus', 'family', 'order', 'class', 'phylum', 'kingdom'];
                    for (const level of levels) {
                        if (result[level] && result[level] !== 'Unknown' && result[level] !== 'N/A') {
                            taxonName = result[level];
                            break;
                        }
                    }
                    taxaCounts[taxonName] = (taxaCounts[taxonName] || 0) + 1;
                });
                
                const abundances = Object.values(taxaCounts);
                const totalIndividuals = abundances.reduce((sum, count) => sum + count, 0);
                const numSpecies = abundances.length;
                
                // Alpha Diversity Metrics
                
                // 1. Species Richness (S)
                const speciesRichness = numSpecies;
                
                // 2. Shannon Index (H')
                let shannonIndex = 0;
                abundances.forEach(count => {
                    const proportion = count / totalIndividuals;
                    if (proportion > 0) {
                        shannonIndex -= proportion * Math.log(proportion);
                    }
                });
                
                // 3. Simpson Index (D) - probability two individuals are same species
                let simpsonIndex = 0;
                abundances.forEach(count => {
                    const proportion = count / totalIndividuals;
                    simpsonIndex += proportion * proportion;
                });
                
                // Simpson's Diversity (1-D) - probability two individuals are different
                const simpsonDiversity = 1 - simpsonIndex;
                
                // 4. Pielou's Evenness (J')
                const maxShannon = Math.log(numSpecies);
                const pielouEvenness = maxShannon > 0 ? shannonIndex / maxShannon : 0;
                
                // Gamma Diversity (total diversity)
                const gammaDiversity = numSpecies;
                
                return {
                    alpha: {
                        speciesRichness: speciesRichness,
                        shannonIndex: shannonIndex.toFixed(3),
                        simpsonIndex: simpsonIndex.toFixed(3),
                        simpsonDiversity: simpsonDiversity.toFixed(3),
                        pielouEvenness: pielouEvenness.toFixed(3)
                    },
                    gamma: {
                        totalDiversity: gammaDiversity
                    },
                    taxaCounts: taxaCounts,
                    totalIndividuals: totalIndividuals
                };
            }
            
            // Display diversity metrics in a card
            function displayDiversityMetrics(metrics) {
                if (!metrics) return;
                
                const metricsCard = document.getElementById('diversityMetricsCard');
                if (!metricsCard) return;
                
                metricsCard.classList.remove('hidden');
                
                let html = `<div class="grid grid-cols-1 md:grid-cols-2 gap-6">`;
                
                // Alpha Diversity Section with gradient
                html += `<div class="p-5 bg-gradient-to-br from-blue-500/10 to-blue-600/5 border border-blue-500/30 rounded-lg relative overflow-hidden">`;
                html += `<div class="absolute top-0 right-0 w-32 h-32 bg-blue-500/5 rounded-full blur-3xl"></div>`;
                html += `<h4 class="text-sm font-semibold text-blue-400 mb-4 uppercase tracking-wider flex items-center gap-2 relative z-10">`;
                html += `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>`;
                html += `Alpha Diversity (α)</h4>`;
                html += `<div class="space-y-2 text-xs relative z-10">`;
                
                const alphaMetrics = [
                    { 
                        label: 'Species Richness (S)', 
                        value: metrics.alpha.speciesRichness, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path></svg>',
                        tooltip: 'The total number of unique species found. Higher values indicate greater biodiversity.'
                    },
                    { 
                        label: "Shannon Index (H')", 
                        value: metrics.alpha.shannonIndex, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path></svg>',
                        tooltip: 'Measures species diversity considering both richness and evenness. Range: 0-5+. Higher values indicate more diverse communities with better species distribution.'
                    },
                    { 
                        label: 'Simpson Index (D)', 
                        value: metrics.alpha.simpsonIndex, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path></svg>',
                        tooltip: 'Probability that two randomly selected individuals belong to the same species. Range: 0-1. Lower values indicate higher diversity.'
                    },
                    { 
                        label: 'Simpson Diversity (1-D)', 
                        value: metrics.alpha.simpsonDiversity, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"></path></svg>',
                        tooltip: 'Inverse of Simpson Index. Range: 0-1. Higher values indicate greater diversity and more balanced species distribution.'
                    },
                    { 
                        label: "Pielou's Evenness (J')", 
                        value: metrics.alpha.pielouEvenness, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6l3 1m0 0l-3 9a5.002 5.002 0 006.001 0M6 7l3 9M6 7l6-2m6 2l3-1m-3 1l-3 9a5.002 5.002 0 006.001 0M18 7l3 9m-3-9l-6-2m0-2v2m0 16V5m0 16H9m3 0h3"></path></svg>',
                        tooltip: 'Measures how evenly species are distributed. Range: 0-1. Values close to 1 indicate all species have similar abundances.'
                    }
                ];
                
                alphaMetrics.forEach(metric => {
                    html += `<div class="flex justify-between items-center py-3 px-3 hover:bg-blue-500/10 rounded-lg transition-all duration-200 group cursor-help relative" title="${metric.tooltip}">`;
                    html += `<span class="text-gray-300 group-hover:text-white transition-colors flex items-center gap-2.5">`;
                    html += `<span class="text-blue-400 opacity-70 group-hover:opacity-100 transition-opacity">${metric.svg}</span>`;
                    html += `<span class="text-sm">${metric.label}</span></span>`;
                    html += `<span class="text-white font-bold font-mono text-lg group-hover:scale-110 transition-transform">${metric.value}</span>`;
                    html += `<div class="absolute left-0 bottom-full mb-2 hidden group-hover:block w-full px-3 py-2 bg-black border border-blue-500/30 rounded-lg text-xs text-gray-300 z-10 pointer-events-none">`;
                    html += `${metric.tooltip}</div></div>`;
                });
                
                html += `</div></div>`;
                
                // Gamma Diversity & Summary Section with gradient
                html += `<div class="p-5 bg-gradient-to-br from-green-500/10 to-emerald-600/5 border border-green-500/30 rounded-lg relative overflow-hidden">`;
                html += `<div class="absolute top-0 right-0 w-32 h-32 bg-green-500/5 rounded-full blur-3xl"></div>`;
                html += `<h4 class="text-sm font-semibold text-green-400 mb-4 uppercase tracking-wider flex items-center gap-2 relative z-10">`;
                html += `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                html += `Gamma Diversity (γ)</h4>`;
                html += `<div class="space-y-2 text-xs relative z-10">`;
                
                const gammaMetrics = [
                    { 
                        label: 'Total Species Diversity', 
                        value: metrics.gamma.totalDiversity, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>',
                        tooltip: 'Total number of unique species across all samples combined. Represents the overall biodiversity of the entire dataset.'
                    },
                    { 
                        label: 'Total Individuals', 
                        value: metrics.totalIndividuals, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>',
                        tooltip: 'Total number of DNA sequences analyzed. Larger sample sizes generally provide more reliable diversity estimates.'
                    }
                ];
                
                gammaMetrics.forEach(metric => {
                    html += `<div class="flex justify-between items-center py-3 px-3 hover:bg-green-500/10 rounded-lg transition-all duration-200 group cursor-help relative" title="${metric.tooltip}">`;
                    html += `<span class="text-gray-300 group-hover:text-white transition-colors flex items-center gap-2.5">`;
                    html += `<span class="text-green-400 opacity-70 group-hover:opacity-100 transition-opacity">${metric.svg}</span>`;
                    html += `<span class="text-sm">${metric.label}</span></span>`;
                    html += `<span class="text-white font-bold font-mono text-lg group-hover:scale-110 transition-transform">${metric.value}</span>`;
                    html += `<div class="absolute left-0 bottom-full mb-2 hidden group-hover:block w-full px-3 py-2 bg-black border border-green-500/30 rounded-lg text-xs text-gray-300 z-10 pointer-events-none">`;
                    html += `${metric.tooltip}</div></div>`;
                });
                
                html += `</div>`;
                
                // Interpretation guide with better styling
                html += `<div class="mt-5 pt-4 border-t border-green-500/20 relative z-10">`;
                html += `<div class="text-green-400 font-semibold mb-3 text-xs uppercase tracking-wide flex items-center gap-2">`;
                html += `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                html += `Quick Guide</div>`;
                html += `<div class="space-y-2 bg-black/30 p-3 rounded-lg text-xs text-gray-400">`;
                html += `<div class="flex items-start gap-2"><svg class="w-3 h-3 mt-0.5 text-green-400 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><circle cx="10" cy="10" r="3"></circle></svg><span><strong class="text-green-300">H':</strong> Higher values indicate more diversity</span></div>`;
                html += `<div class="flex items-start gap-2"><svg class="w-3 h-3 mt-0.5 text-green-400 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><circle cx="10" cy="10" r="3"></circle></svg><span><strong class="text-green-300">D:</strong> Lower values indicate more diversity</span></div>`;
                html += `<div class="flex items-start gap-2"><svg class="w-3 h-3 mt-0.5 text-green-400 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><circle cx="10" cy="10" r="3"></circle></svg><span><strong class="text-green-300">J':</strong> Values close to 1 indicate high evenness</span></div>`;
                html += `</div></div>`;
                
                html += `</div>`;
                
                html += `</div>`;
                
                document.getElementById('diversityMetricsContent').innerHTML = html;
            }

            // Function to display batch results in a clean table with pagination
            function displayBatchResults(results) {
                if (!results || results.length === 0) {
                    classificationResultEl.innerHTML = '<p class="text-gray-500">No results to display.</p>';
                    return;
                }
                
                // Calculate pagination
                const totalPages = Math.ceil(results.length / resultsPerPage);
                const startIndex = (currentPage - 1) * resultsPerPage;
                const endIndex = Math.min(startIndex + resultsPerPage, results.length);
                const currentResults = results.slice(startIndex, endIndex);
                
                let tableHTML = `<div class="overflow-x-auto">`;
                tableHTML += `<table class="w-full text-xs font-mono">`;
                tableHTML += `<thead class="border-b border-[#27272a]">`;
                tableHTML += `<tr class="text-left">`;
                tableHTML += `<th class="py-2 px-3 text-gray-500 font-semibold">SAMPLE ID</th>`;
                tableHTML += `<th class="py-2 px-3 text-gray-500 font-semibold">MARKER</th>`;
                tableHTML += `<th class="py-2 px-3 text-gray-500 font-semibold">TAXONOMIC LINEAGE</th>`;
                tableHTML += `<th class="py-2 px-3 text-gray-500 font-semibold text-center">STATUS</th>`;
                tableHTML += `<th class="py-2 px-3 text-gray-500 font-semibold">UID</th>`;
                tableHTML += `</tr></thead><tbody>`;
                
                currentResults.forEach((result, index) => {
                    const bgClass = index % 2 === 0 ? 'bg-black/30' : 'bg-black/10';
                    tableHTML += `<tr class="${bgClass} hover:bg-white/5 transition">`;
                    
                    // Sample ID
                    tableHTML += `<td class="py-3 px-3 text-gray-400">${result.original_sample_id || 'N/A'}</td>`;
                    
                    // Marker
                    tableHTML += `<td class="py-3 px-3"><span class="px-2 py-1 bg-blue-500/10 text-blue-400 rounded text-xs">${result.marker_label || 'N/A'}</span></td>`;
                    
                    // Taxonomic lineage - build hierarchical path with emphasis on key levels
                    const levels = [
                        { key: 'kingdom', label: 'K', color: 'text-purple-400' },
                        { key: 'phylum', label: 'P', color: 'text-blue-400' },
                        { key: 'class', label: 'C', color: 'text-cyan-400' },
                        { key: 'order', label: 'O', color: 'text-teal-400' },
                        { key: 'family', label: 'F', color: 'text-green-400' },
                        { key: 'genus', label: 'G', color: 'text-yellow-400' },
                        { key: 'species', label: 'S', color: 'text-orange-400' }
                    ];
                    
                    // Find the deepest known level for emphasis
                    let deepestLevel = null;
                    let deepestIndex = -1;
                    levels.forEach((level, idx) => {
                        if (result[level.key] && result[level.key] !== 'Unknown' && result[level.key] !== 'N/A') {
                            deepestLevel = level;
                            deepestIndex = idx;
                        }
                    });
                    
                    const lineageParts = [];
                    levels.forEach((level, idx) => {
                        if (result[level.key] && result[level.key] !== 'Unknown' && result[level.key] !== 'N/A') {
                            const isDeepest = idx === deepestIndex;
                            const isFamilyOrBelow = idx >= 4; // Family, Genus, Species
                            
                            // Make the deepest level (most specific) stand out with larger, bolder text
                            if (isDeepest && isFamilyOrBelow) {
                                lineageParts.push(`
                                    <span class="inline-flex items-center gap-1.5 px-2.5 py-1 bg-gradient-to-r from-${level.color.replace('text-', '')}/20 to-${level.color.replace('text-', '')}/10 border border-${level.color.replace('text-', '')}/30 rounded-md">
                                        <span class="text-[10px] font-semibold ${level.color} opacity-70">${level.label}</span>
                                        <span class="text-sm font-bold text-white">${result[level.key]}</span>
                                    </span>
                                `);
                            } else {
                                lineageParts.push(`<span class="text-[10px] ${level.color} opacity-60">${level.label}:</span> <span class="text-xs text-gray-300">${result[level.key]}</span>`);
                            }
                        }
                    });
                    
                    const lineageDisplay = lineageParts.length > 0 ? 
                        `<div class="flex flex-wrap items-center gap-x-2 gap-y-1">${lineageParts.join(' <span class="text-gray-700 text-[10px]">→</span> ')}</div>` : 
                        '<span class="text-gray-600 text-xs">Unknown</span>';
                    tableHTML += `<td class="py-3 px-3">${lineageDisplay}</td>`;
                    
                    // Status badge
                    if (result.is_novel) {
                        tableHTML += `<td class="py-3 px-3 text-center"><span class="px-2 py-1 bg-yellow-500/10 text-yellow-400 border border-yellow-500/30 rounded-full text-xs font-semibold">NOVEL</span></td>`;
                    } else {
                        tableHTML += `<td class="py-3 px-3 text-center"><span class="px-2 py-1 bg-green-500/10 text-green-400 border border-green-500/30 rounded-full text-xs font-semibold">KNOWN</span></td>`;
                    }
                    
                    // UID
                    tableHTML += `<td class="py-3 px-3 ${result.uid ? 'text-yellow-300' : 'text-gray-600'}">${result.uid || '-'}</td>`;
                    
                    tableHTML += `</tr>`;
                });
                
                tableHTML += `</tbody></table></div>`;
                
                // Pagination controls
                tableHTML += `<div class="mt-4 pt-4 border-t border-[#27272a] flex justify-between items-center">`;
                
                // Left side - Summary stats
                const knownCount = results.filter(r => !r.is_novel).length;
                const novelCount = results.filter(r => r.is_novel).length;
                tableHTML += `<div class="text-xs space-x-4">`;
                tableHTML += `<span class="text-gray-500">Total: <span class="text-white font-semibold">${results.length}</span></span>`;
                tableHTML += `<span class="text-gray-500">Known: <span class="text-green-400 font-semibold">${knownCount}</span></span>`;
                tableHTML += `<span class="text-gray-500">Novel: <span class="text-yellow-400 font-semibold">${novelCount}</span></span>`;
                tableHTML += `</div>`;
                
                // Right side - Pagination
                tableHTML += `<div class="flex items-center gap-3">`;
                
                // Page info
                tableHTML += `<span class="text-xs text-gray-400">Page <span class="text-white font-semibold">${currentPage}</span> of <span class="text-white">${totalPages}</span></span>`;
                
                // Previous button
                const prevDisabled = currentPage === 1;
                tableHTML += `<button id="prevPageBtn" ${prevDisabled ? 'disabled' : ''} class="${prevDisabled ? 'opacity-30 cursor-not-allowed' : 'hover:bg-white/10'} p-2 border border-[#27272a] rounded transition">`;
                tableHTML += `<svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">`;
                tableHTML += `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg></button>`;
                
                // Next button
                const nextDisabled = currentPage === totalPages;
                tableHTML += `<button id="nextPageBtn" ${nextDisabled ? 'disabled' : ''} class="${nextDisabled ? 'opacity-30 cursor-not-allowed' : 'hover:bg-white/10'} p-2 border border-[#27272a] rounded transition">`;
                tableHTML += `<svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">`;
                tableHTML += `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg></button>`;
                
                tableHTML += `</div></div>`;
                
                classificationResultEl.innerHTML = tableHTML;
                
                // Add event listeners for pagination buttons
                document.getElementById('prevPageBtn')?.addEventListener('click', () => {
                    if (currentPage > 1) {
                        currentPage--;
                        displayBatchResults(window.currentBatchResults);
                    }
                });
                
                document.getElementById('nextPageBtn')?.addEventListener('click', () => {
                    if (currentPage < totalPages) {
                        currentPage++;
                        displayBatchResults(window.currentBatchResults);
                    }
                });
            }
            
            // Export results to CSV
            const exportBtn = document.getElementById('exportResultsBtn');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                if (!window.currentBatchResults || window.currentBatchResults.length === 0) {
                    alert('No results to export');
                    return;
                }
                
                let csv = 'Sample ID,Marker,Kingdom,Phylum,Class,Order,Family,Genus,Species,Status,UID\\n';
                window.currentBatchResults.forEach(result => {
                    csv += `"${result.original_sample_id || 'N/A'}",`;
                    csv += `"${result.marker_label || 'N/A'}",`;
                    csv += `"${result.kingdom || 'N/A'}",`;
                    csv += `"${result.phylum || 'N/A'}",`;
                    csv += `"${result.class || 'N/A'}",`;
                    csv += `"${result.order || 'N/A'}",`;
                    csv += `"${result.family || 'N/A'}",`;
                    csv += `"${result.genus || 'N/A'}",`;
                    csv += `"${result.species || 'N/A'}",`;
                    csv += `"${result.is_novel ? 'NOVEL' : 'KNOWN'}",`;
                    csv += `"${result.uid || ''}"\\n`;
                });
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `bio-line-results-${new Date().toISOString().slice(0,10)}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                });
            }
            
            // Verify novel species against databases
            const verifyDbBtn = document.getElementById('verifyDatabaseBtn');
            if (verifyDbBtn) {
                verifyDbBtn.addEventListener('click', async () => {
                if (!window.currentBatchResults || window.currentBatchResults.length === 0) {
                    alert('No results to verify');
                    return;
                }
                
                // Find novel species
                const novelSpecies = window.currentBatchResults.filter(r => r.is_novel && r.uid);
                
                if (novelSpecies.length === 0) {
                    alert('No novel species found in the results');
                    return;
                }
                
                const verifyBtn = document.getElementById('verifyDatabaseBtn');
                verifyBtn.disabled = true;
                verifyBtn.textContent = '🔍 Searching databases...';
                
                pipelineStatusEl.innerHTML += `<br><span class="text-blue-400">[DATABASE VERIFICATION] Searching NCBI, SILVA, PR2...</span>`;
                
                try {
                    const dbSearcher = new DatabaseSearcher();
                    let matchCount = 0;
                    let reclassifiedCount = 0;
                    
                    for (const result of novelSpecies) {
                        // Get the marker type
                        const marker = result.marker_label && result.marker_label.toLowerCase().includes('coi') ? 'COI' : '18S';
                        
                        // Search databases silently
                        const searchResult = await dbSearcher.searchAllDatabases(marker, result.sequence || '');
                        
                        if (searchResult.found) {
                            matchCount++;
                            const dbLineage = searchResult.bestMatch.lineage;
                            const similarity = searchResult.bestMatch.similarity;
                            
                            // Update the result in currentBatchResults
                            result.kingdom = dbLineage.kingdom || result.kingdom;
                            result.phylum = dbLineage.phylum || result.phylum;
                            result.class = dbLineage.class || result.class;
                            result.order = dbLineage.order || result.order;
                            result.family = dbLineage.family || result.family;
                            result.genus = dbLineage.genus || result.genus;
                            result.species = dbLineage.species || result.species;
                            
                            // If high similarity, mark as known
                            if (parseFloat(similarity) >= 95) {
                                result.is_novel = false;
                                result.uid = null;
                                reclassifiedCount++;
                            }
                        }
                    }
                    
                    // Show clean summary
                    if (matchCount > 0) {
                        pipelineStatusEl.innerHTML += `<br><span class="text-green-400">[VERIFICATION COMPLETE] ${matchCount} match(es) found in databases (${reclassifiedCount} reclassified as known)</span>`;
                        // Refresh the display with updated data
                        currentPage = 1;
                        displayBatchResults(window.currentBatchResults);
                        // Also update the novelty count in the summary
                        const noveltyCard = document.getElementById('noveltyResult');
                        const updatedNovelCount = window.currentBatchResults.filter(r => r.is_novel === true).length;
                        if (noveltyCard && updatedNovelCount === 0) {
                            noveltyCard.innerHTML = '<div class="text-center text-gray-400">No novel species detected</div>';
                        }
                    } else {
                        pipelineStatusEl.innerHTML += `<br><span class="text-yellow-400">[VERIFICATION COMPLETE] No matches found in databases</span>`;
                    }
                    
                    console.log('Database verification completed. Match count:', matchCount, 'Reclassified:', reclassifiedCount);
                    
                } catch (error) {
                    console.error('Database verification error:', error);
                    pipelineStatusEl.innerHTML += `<br><span class="text-red-400">[ERROR] Database verification failed: ${error.message}</span>`;
                    alert('Database verification failed: ' + error.message);
                } finally {
                    const verifyBtnFinal = document.getElementById('verifyDatabaseBtn');
                    if (verifyBtnFinal) {
                        verifyBtnFinal.disabled = false;
                        verifyBtnFinal.textContent = '🔍 Verify Novel Species';
                    }
                }
                });
            }

            async function performSingleAnalysis(rawSequence) {
                resultsSection.classList.remove('hidden');
                classificationResultEl.innerHTML = '<p class="text-gray-500">Awaiting classification results...</p>';
                markerResultsCard.classList.add('hidden');
                markerResultsContent.innerHTML = '';
                analyzeBtn.disabled = true;
                analyzeBtn.textContent = 'Analyzing...';
                try {
                    pipelineStatusEl.innerHTML = '<span class="text-yellow-400">[1/2] Detecting gene markers (COI/18sRNA)...</span>';
                    const sequence = rawSequence.replace(/>.*/g, '').replace(/\s/g, '').toUpperCase();
                    if (!/^[ATCGN]+$/.test(sequence)) throw new Error("Input contains invalid characters. Only A, T, G, C, and N are allowed.");
                    const markerData = await callGeneMarkerApi(sequence);
                    const markers = filterRelevantMarkers(markerData.predictions || []);
                    if (markers.length === 0) throw new Error("No relevant gene markers (COI or 18sRNA) were detected.");
                   
                    markerResultsCard.classList.remove('hidden');
                    let markerHTML = `<p class="text-sm text-gray-300 mb-4">Detected ${markers.length} relevant marker(s):</p>`;
                    markers.forEach(marker => {
                        markerHTML += `<div class="p-3 bg-black border border-[#27272a] rounded-md mb-2"><p class="font-semibold text-white">${marker.label}</p><p class="text-xs text-gray-400 break-all mt-1 font-mono">${marker.sequence.substring(0, 100)}...</p></div>`;
                    });
                    markerResultsContent.innerHTML = markerHTML;
                    pipelineStatusEl.innerHTML = `<span class="text-green-400">[1/2] Marker detection complete.</span>`;
                   
                    pipelineStatusEl.innerHTML += '<br><span class="text-yellow-400">[2/2] Classifying detected marker(s)...</span>';
                    classificationResultEl.innerHTML = '';
                    for (const marker of markers) {
                        const taxaData = await callDnabertApi(marker.sequence, marker.label);
                        populateSingleResult(taxaData, marker.label);
                    }
                    pipelineStatusEl.innerHTML += `<br><span class="text-green-400">[2/2] Classification complete. [OK]</span>`;
                } catch (error) {
                    console.error('Analysis Failed:', error);
                    pipelineStatusEl.innerHTML = `<div class="text-red-500 p-2 border border-red-500/50 bg-red-500/10 rounded-md"><b>Error:</b> ${error.message}</div>`;
                    populateSingleResult(null);
                } finally {
                    analyzeBtn.disabled = false;
                    analyzeBtn.textContent = analyzeButtonText;
                }
            }

            async function callGeneMarkerApi(sequence) {
                const response = await fetch(`${GENE_MARKER_API_URL}/predict-text/`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sequence }) });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Gene Marker API Error (${response.status}): ${errorData.detail || 'Failed to fetch'}`);
                }
                return await response.json();
            }

            function filterRelevantMarkers(predictions) {
                const coiPredictions = predictions.filter(p => p.label.toLowerCase().includes('coi'));
                const bestCOI = coiPredictions.length > 0 ? coiPredictions.reduce((max, p) => p.confidence > max.confidence ? p : max, coiPredictions[0]) : null;
                const rRNAPredictions = predictions.filter(p => p.label.toLowerCase().includes('18s'));
                const best18sRNA = rRNAPredictions.length > 0 ? rRNAPredictions.reduce((max, p) => p.confidence > max.confidence ? p : max, rRNAPredictions[0]) : null;
                if (bestCOI && best18sRNA) return bestCOI.confidence >= best18sRNA.confidence ? [bestCOI] : [best18sRNA];
                if (bestCOI) return [bestCOI];
                if (best18sRNA) return [best18sRNA];
                return [];
            }
           
            async function callDnabertApi(sequence, markerType = 'Unknown') {
                const response = await fetch(DNABERT_API_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sequence }) });
                if (!response.ok) throw new Error(`Bio-Line API Error (${response.status}): ${await response.text()}`);
                const apiResult = await response.json();
                
                // Transform the new API response structure to match our expected format
                const classification = apiResult.classification || {};
                
                // Find the deepest known taxonomic level
                const lineageLevels = ['Species', 'Genus', 'Family', 'Order', 'Class', 'Phylum', 'Kingdom'];
                let deepestKnownLevel = 'Unknown';
                let deepestKnownValue = 'Unknown';
                
                for (const level of lineageLevels) {
                    if (classification[level] && classification[level] !== 'Unknown' && classification[level] !== 'N/A') {
                        deepestKnownLevel = level;
                        deepestKnownValue = classification[level];
                        break;
                    }
                }
                
                let is_novel = apiResult.is_novel || false;
                let uid = apiResult.uid || null;
                let database_search_result = null;
                
                const result = {
                    classification: classification,
                    is_novel: is_novel,
                    uid: uid,
                    message: apiResult.message || '',
                    database_search: database_search_result,
                    // Create backwards compatible fields
                    predicted_taxa: deepestKnownValue,
                    predicted_level: deepestKnownLevel,
                    predicted_group: classification.Kingdom || 'Unknown',
                    // Since new API doesn't provide confidence, assume high confidence unless novel
                    taxa_confidence: is_novel ? 0.5 : 0.95,
                    group_confidence: is_novel ? 0.5 : 0.95,
                    novelty_status: is_novel ? `Novel Species - UID: ${uid}` : 'Known Species',
                    // Full lineage
                    kingdom: classification.Kingdom,
                    phylum: classification.Phylum,
                    class: classification.Class,
                    order: classification.Order,
                    family: classification.Family,
                    genus: classification.Genus,
                    species: classification.Species
                };
                
                return result;
            }
           
            async function generateAndDisplayInsights(results) {
                 pipelineStatusEl.innerHTML += '<br><span class="text-yellow-400">Generating ecological insights (~30 seconds)...</span>';
                 insightsResultEl.innerHTML = '<p class="text-gray-500">Generating ecological insights (~30s)...</p>';
                 const apiKey = "AIzaSyDHT_bxYVMS5--RMVjEiCnKg9yGe73b-z8";
                 
                 // Create better aggregated data grouped by deepest known level
                 const counts = results.reduce((acc, result) => {
                      if (result.predicted_taxa === "ERROR") return acc;
                      
                      // Find deepest known taxonomic level
                      let taxonName = 'Unknown';
                      let taxonLevel = 'Unknown';
                      const levels = [
                          { key: 'species', name: 'Species' },
                          { key: 'genus', name: 'Genus' },
                          { key: 'family', name: 'Family' },
                          { key: 'order', name: 'Order' },
                          { key: 'class', name: 'Class' },
                          { key: 'phylum', name: 'Phylum' },
                          { key: 'kingdom', name: 'Kingdom' }
                      ];
                      
                      for (const level of levels) {
                          if (result[level.key] && result[level.key] !== 'Unknown' && result[level.key] !== 'N/A') {
                              taxonName = result[level.key];
                              taxonLevel = level.name;
                              break;
                          }
                      }
                      
                      const key = `${taxonName} (${taxonLevel})`;
                      if (!acc[key]) acc[key] = { 
                          count: 0, 
                          level: taxonLevel,
                          kingdom: result.kingdom || 'Unknown',
                          phylum: result.phylum || 'Unknown',
                          class: result.class || 'Unknown',
                          is_novel: false
                      };
                      acc[key].count++;
                      if (result.is_novel) acc[key].is_novel = true;
                      return acc;
                 }, {});
                 
                 const aggregatedData = Object.entries(counts).map(([taxa, data]) => ({
                     taxon: taxa,
                     taxonomic_level: data.level,
                     abundance: data.count,
                     kingdom: data.kingdom,
                     phylum: data.phylum,
                     class: data.class,
                     is_novel: data.is_novel
                 }));
                 
                 const sampleId = "BatchAnalysis-" + new Date().toISOString().slice(0,10);
                 const environment = document.getElementById('environmentType').value || 'Not Specified';
                 const depth = document.getElementById('batchDepth').value || 'Not Specified';
                 
                 // Calculate kingdom distribution
                 const kingdomCounts = results.reduce((acc, r) => {
                     const k = r.kingdom || 'Unknown';
                     acc[k] = (acc[k] || 0) + 1;
                     return acc;
                 }, {});
                 
                 const prompt = `You are an expert marine ecologist. Your task is to generate a concise ecological insights report in a structured JSON format based on eDNA sample data.\n\n### CONTEXT\n- Sample ID: ${sampleId}\n- Environment Type: ${environment}\n- Depth: ${depth} meters\n- Total Sequences Analyzed: ${results.length}\n- Kingdom Distribution: ${JSON.stringify(kingdomCounts)}\n\n### INPUT DATA\nThe data below shows taxa grouped at their deepest known taxonomic level:\n\`\`\`json\n${JSON.stringify(aggregatedData, null, 2)}\n\`\`\`\n\n### YOUR TASK\nAnalyze the data and return a JSON object with the exact following structure:\n\n1. **summary**: Provide a 2-3 sentence overview of the sample\n2. **biodiversity_assessment**: \n   - "richness_value": Count of unique taxa (number)\n   - "evenness_category": 'Low', 'Moderate', or 'High' based on abundance distribution\n   - "insight": 2-3 sentence analysis\n3. **community_structure**: \n   - Analyze the actual kingdom/phylum distribution found in the data\n   - "major_groups": Object with counts for each major group found (e.g., {"Eukaryota": 15, "Bacteria": 3})\n   - "insight": 2-3 sentence analysis of community composition\n4. **dominant_taxa**: Identify top 3-5 most abundant taxa and their ecological significance\n5. **trophic_levels**: Discuss likely ecological roles based on identified taxa\n6. **bioindicators**: Discuss if any identified taxa are known bioindicators\n\n### REQUIRED JSON OUTPUT STRUCTURE\n\`\`\`json\n{\n  "summary": { "title": "Ecological Summary", "insight": "" },\n  "biodiversity_assessment": { "title": "Biodiversity Assessment", "insight": "", "richness_value": 0, "evenness_category": "" },\n  "community_structure": { "title": "Community Structure", "insight": "", "major_groups": {} },\n  "dominant_taxa": { "title": "Dominant Taxa & Significance", "insight": "" },\n  "trophic_levels": { "title": "Ecological Roles & Food Web", "insight": "" },\n  "bioindicators": { "title": "Bioindicator Analysis", "insight": "" }\n}\n\`\`\`\n\nIMPORTANT: Base your analysis ONLY on the actual data provided. Do not assume Protista/Metazoa unless those groups appear in the kingdom distribution.`;
                 try {
                      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) });
                      if (!response.ok) throw new Error(`Gemini API Error (${response.status}): ${await response.text()}`);
                      const result = await response.json();
                      if (!result.candidates?.[0]?.content?.parts?.[0]) throw new Error("Invalid response structure from Gemini API.");
                      const rawText = result.candidates[0].content.parts[0].text;
                      const jsonMatch = rawText.match(/\{[\s\S]*\}/);
                      if (!jsonMatch) throw new Error("Invalid JSON response from Gemini API.");
                      const insights = JSON.parse(jsonMatch[0]);
                      currentInsightsData = insights; // Store for PDF generation
                      displayEcologicalInsights(insights);
                      generateReportBtn.classList.remove('hidden');
                      chatBtn.classList.remove('hidden'); // Show chat button
                      pipelineStatusEl.innerHTML += `<br><span class="text-green-400">Insights generated. [OK]</span>`;
                 } catch (error) {
                      console.error("Gemini API call failed:", error);
                      insightsResultEl.innerHTML = `<div class="text-red-500 font-light">Failed to generate insights: ${error.message}</div>`;
                      pipelineStatusEl.innerHTML += `<br><span class="text-red-500">Failed to generate insights.</span>`;
                 }
            }
           
            function displayEcologicalInsights(insights) {
                insightsResultEl.innerHTML = '';
                if (!insights) { insightsResultEl.innerHTML = '<p class="text-gray-500">No insights were generated.</p>'; return; }
                const createInsightBlock = (item) => `<div class="border-l-2 border-[#27272a] pl-4"><h4 class="font-semibold text-white tracking-wide">${item.title || 'Insight'}</h4><p class="text-gray-400 mt-1">${item.insight || 'No details provided.'}</p></div>`;
                if (insights.summary) insightsResultEl.innerHTML += createInsightBlock(insights.summary);
                if (insights.biodiversity_assessment) {
                    const item = insights.biodiversity_assessment;
                    const infographicHTML = `<div class="grid grid-cols-2 gap-4 mt-3 pt-3 border-t border-[#27272a]/50"><div class="text-center p-2 bg-black/50 rounded-md"><div class="text-2xl font-bold text-white">${item.richness_value || 'N/A'}</div><div class="text-xs text-gray-400 uppercase tracking-wider font-mono">Taxa Richness</div></div><div class="text-center p-2 bg-black/50 rounded-md"><div class="text-2xl font-bold text-white">${item.evenness_category || 'N/A'}</div><div class="text-xs text-gray-400 uppercase tracking-wider font-mono">Evenness</div></div></div>`;
                    insightsResultEl.innerHTML += createInsightBlock(item) + infographicHTML;
                }
                if (insights.community_structure) {
                    const item = insights.community_structure;
                    let communityHTML = createInsightBlock(item);
                    
                    // Group by Phylum for better diversity visualization
                    const phylumCounts = {};
                    if (window.currentBatchResults && window.currentBatchResults.length > 0) {
                        window.currentBatchResults.forEach(result => {
                            if (result.phylum && result.phylum !== 'Unknown' && result.phylum !== 'N/A') {
                                phylumCounts[result.phylum] = (phylumCounts[result.phylum] || 0) + 1;
                            } else {
                                phylumCounts['Unclassified'] = (phylumCounts['Unclassified'] || 0) + 1;
                            }
                        });
                    }
                    
                    // Display phylum diversity chart if available
                    if (Object.keys(phylumCounts).length > 0) {
                        communityHTML += `<div class="mt-4 pt-4 border-t border-[#27272a]/50">`;
                        communityHTML += `<div class="text-xs text-gray-400 mb-3 text-center uppercase tracking-wider">Phylum-Level Diversity</div>`;
                        communityHTML += `<div class="w-full" style="height: 280px;"><canvas id="communityDonutChart"></canvas></div></div>`;
                        insightsResultEl.innerHTML += communityHTML;
                        
                        // Create chart with phylum groups
                        setTimeout(() => {
                            const labels = Object.keys(phylumCounts);
                            const data = Object.values(phylumCounts);
                            const chartInstance = Chart.getChart('communityDonutChart');
                            if(chartInstance) chartInstance.destroy();
                            const ctx = document.getElementById('communityDonutChart').getContext('2d');
                            
                            // Darker, muted color palette with subtle elegance
                            const colorPalette = [
                                { bg: 'rgba(59, 130, 246, 0.75)', border: 'rgb(37, 99, 235)', glow: 'rgba(59, 130, 246, 0.3)' },      // Deep Blue
                                { bg: 'rgba(236, 72, 153, 0.75)', border: 'rgb(219, 39, 119)', glow: 'rgba(236, 72, 153, 0.3)' },     // Deep Pink
                                { bg: 'rgba(16, 185, 129, 0.75)', border: 'rgb(5, 150, 105)', glow: 'rgba(16, 185, 129, 0.3)' },       // Deep Green
                                { bg: 'rgba(245, 158, 11, 0.75)', border: 'rgb(217, 119, 6)', glow: 'rgba(245, 158, 11, 0.3)' },       // Deep Amber
                                { bg: 'rgba(168, 85, 247, 0.75)', border: 'rgb(147, 51, 234)', glow: 'rgba(168, 85, 247, 0.3)' },      // Deep Purple
                                { bg: 'rgba(14, 165, 233, 0.75)', border: 'rgb(2, 132, 199)', glow: 'rgba(14, 165, 233, 0.3)' },       // Deep Cyan
                                { bg: 'rgba(239, 68, 68, 0.75)', border: 'rgb(220, 38, 38)', glow: 'rgba(239, 68, 68, 0.3)' },         // Deep Red
                                { bg: 'rgba(132, 204, 22, 0.75)', border: 'rgb(101, 163, 13)', glow: 'rgba(132, 204, 22, 0.3)' }       // Deep Lime
                            ];
                            
                            const backgroundColors = labels.map((_, i) => colorPalette[i % colorPalette.length].bg);
                            const borderColors = labels.map((_, i) => colorPalette[i % colorPalette.length].border);
                            
                            new Chart(ctx, { 
                                type: 'doughnut', 
                                data: { 
                                    labels: labels, 
                                    datasets: [{ 
                                        data: data, 
                                        backgroundColor: backgroundColors, 
                                        borderColor: borderColors, 
                                        borderWidth: 3,
                                        hoverOffset: 15,
                                        hoverBorderWidth: 4
                                    }] 
                                }, 
                                options: {
                                    animation: {
                                        animateRotate: true,
                                        animateScale: true,
                                        duration: 1200,
                                        easing: 'easeOutQuart'
                                    },
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    cutout: '60%',
                                    plugins: { 
                                        legend: { 
                                            position: 'right',
                                            align: 'center',
                                            labels: { 
                                                color: '#ffffff',  // White for UI (changed to black during PDF export)
                                                boxWidth: 18,
                                                boxHeight: 18,
                                                padding: 16,
                                                font: { 
                                                    family: "'Inter', sans-serif",
                                                    size: 12,
                                                    weight: '600'
                                                },
                                                usePointStyle: false,
                                                generateLabels: function(chart) {
                                                    const data = chart.data;
                                                    if (data.labels.length && data.datasets.length) {
                                                        return data.labels.map((label, i) => {
                                                            const meta = chart.getDatasetMeta(0);
                                                            const value = data.datasets[0].data[i];
                                                            const total = data.datasets[0].data.reduce((a, b) => a + b, 0);
                                                            const percentage = ((value / total) * 100).toFixed(1);
                                                            return {
                                                                text: `${label} (${percentage}%)`,
                                                                fillStyle: data.datasets[0].backgroundColor[i],
                                                                strokeStyle: data.datasets[0].borderColor[i],
                                                                lineWidth: 2,
                                                                fontColor: '#ffffff',  // White for UI
                                                                hidden: !meta.data[i] || meta.data[i].hidden,
                                                                index: i
                                                            };
                                                        });
                                                    }
                                                    return [];
                                                }
                                            } 
                                        },
                                        tooltip: {
                                            backgroundColor: 'rgba(0, 0, 0, 0.95)',
                                            padding: 14,
                                            titleColor: '#fff',
                                            titleFont: { size: 13, weight: 'bold' },
                                            bodyColor: '#d1d5db',
                                            bodyFont: { size: 12 },
                                            borderColor: 'rgba(255, 255, 255, 0.2)',
                                            borderWidth: 2,
                                            cornerRadius: 8,
                                            displayColors: true,
                                            callbacks: {
                                                label: function(context) {
                                                    const label = context.label || '';
                                                    const value = context.parsed;
                                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                                    const percentage = ((value / total) * 100).toFixed(1);
                                                    return [
                                                        `${label}`,
                                                        `Count: ${value}`,
                                                        `Percentage: ${percentage}%`
                                                    ];
                                                }
                                            }
                                        }
                                    } 
                                } 
                            });
                        }, 0);
                    } else {
                        insightsResultEl.innerHTML += communityHTML;
                    }
                } else {
                }
                if (insights.dominant_taxa) insightsResultEl.innerHTML += createInsightBlock(insights.dominant_taxa);
                if (insights.trophic_levels) insightsResultEl.innerHTML += createInsightBlock(insights.trophic_levels);
                if (insights.bioindicators) insightsResultEl.innerHTML += createInsightBlock(insights.bioindicators);
            }

            function populateSingleResult(apiData, markerLabel = '') {
                if (apiData) {
                    // Build clean lineage display
                    let lineageHTML = `<div class="p-5 bg-black/50 border border-[#27272a] rounded-lg">`;
                    
                    // Header with marker info
                    lineageHTML += `<div class="flex justify-between items-center mb-4 pb-3 border-b border-[#27272a]/50">`;
                    lineageHTML += `<div><span class="text-xs text-gray-500 uppercase tracking-wider">Gene Marker</span>`;
                    lineageHTML += `<div class="text-white font-semibold mt-1">${markerLabel}</div></div>`;
                    
                    // Novelty badge
                    if (apiData.is_novel) {
                        lineageHTML += `<div class="px-3 py-1 bg-yellow-500/10 border border-yellow-500/30 rounded-full">`;
                        lineageHTML += `<span class="text-yellow-400 font-bold text-xs">🆕 NOVEL</span></div>`;
                    } else {
                        lineageHTML += `<div class="px-3 py-1 bg-green-500/10 border border-green-500/30 rounded-full">`;
                        lineageHTML += `<span class="text-green-400 font-bold text-xs">✓ KNOWN</span></div>`;
                    }
                    lineageHTML += `</div>`;
                    
                    // UID if novel
                    if (apiData.is_novel && apiData.uid) {
                        lineageHTML += `<div class="mb-4 p-3 bg-yellow-500/5 border border-yellow-500/20 rounded">`;
                        lineageHTML += `<div class="text-xs text-gray-400">Unique Identifier</div>`;
                        lineageHTML += `<div class="text-yellow-300 font-mono font-semibold mt-1">${apiData.uid}</div></div>`;
                    }
                    
                    // Taxonomic lineage - only show known levels
                    lineageHTML += `<div class="space-y-0 font-mono text-sm">`;
                    const lineageLevels = [
                        { label: 'Kingdom', value: apiData.kingdom, color: 'text-blue-400' },
                        { label: 'Phylum', value: apiData.phylum, color: 'text-cyan-400' },
                        { label: 'Class', value: apiData.class, color: 'text-teal-400' },
                        { label: 'Order', value: apiData.order, color: 'text-green-400' },
                        { label: 'Family', value: apiData.family, color: 'text-yellow-400' },
                        { label: 'Genus', value: apiData.genus, color: 'text-orange-400' },
                        { label: 'Species', value: apiData.species, color: 'text-red-400' }
                    ];
                    
                    let foundLast = false;
                    lineageLevels.forEach((level, index) => {
                        // Only show levels that have values and stop at first Unknown/N/A
                        if (!foundLast && level.value && level.value !== 'Unknown' && level.value !== 'N/A') {
                            const indent = '  '.repeat(index);
                            const connector = index > 0 ? '└─ ' : '';
                            lineageHTML += `<div class="flex items-start py-1.5 hover:bg-white/5 rounded px-2 -mx-2 transition">`;
                            lineageHTML += `<span class="text-gray-600 w-28 text-xs flex-shrink-0">${indent}${connector}${level.label}</span>`;
                            lineageHTML += `<span class="${level.color} font-semibold flex-1">${level.value}</span>`;
                            lineageHTML += `</div>`;
                        } else if (!level.value || level.value === 'Unknown' || level.value === 'N/A') {
                            foundLast = true;
                        }
                    });
                    
                    lineageHTML += `</div></div>`;
                    
                    classificationResultEl.innerHTML = lineageHTML;
                    noveltyResultEl.innerHTML = apiData.is_novel 
                        ? `<div class="text-center"><div class="text-3xl font-bold text-yellow-400">1</div><div class="text-xs text-gray-400 mt-1">Novel Species</div><div class="text-xs text-yellow-500 mt-2 font-mono">${apiData.uid}</div></div>` 
                        : `<div class="text-center"><div class="text-3xl font-bold text-green-400">0</div><div class="text-xs text-gray-400 mt-1">Novel Species</div><div class="text-xs text-gray-500 mt-2">Known Classification</div></div>`;
                } else {
                    classificationResultEl.innerHTML = '<div class="text-gray-500">Analysis failed. See status.</div>';
                    noveltyResultEl.innerHTML = 'N/A';
                }
                updateAbundanceChart([]);
                insightsResultEl.innerHTML = '<p class="text-gray-500">Ecological insights are only available for batch analysis.</p>';
            }
           
            function updateAbundanceChart(results) {
                 // Smart grouping strategy: Group by Family > Order > Class > Phylum based on what's available
                 const counts = results.reduce((acc, result) => {
                     let groupName = 'Unclassified';
                     let groupLevel = '';
                     
                     // Priority grouping: prefer Family or Order for meaningful ecological groups
                     if (result.family && result.family !== 'Unknown' && result.family !== 'N/A') {
                         groupName = result.family;
                         groupLevel = 'Family';
                     } else if (result.order && result.order !== 'Unknown' && result.order !== 'N/A') {
                         groupName = result.order;
                         groupLevel = 'Order';
                     } else if (result.class && result.class !== 'Unknown' && result.class !== 'N/A') {
                         groupName = result.class;
                         groupLevel = 'Class';
                     } else if (result.phylum && result.phylum !== 'Unknown' && result.phylum !== 'N/A') {
                         groupName = result.phylum;
                         groupLevel = 'Phylum';
                     } else if (result.kingdom && result.kingdom !== 'Unknown' && result.kingdom !== 'N/A') {
                         groupName = result.kingdom;
                         groupLevel = 'Kingdom';
                     }
                     
                     // Use full name without abbreviation for cleaner display
                     acc[groupName] = (acc[groupName] || 0) + 1;
                     return acc;
                 }, {});
                 
                 // Sort by abundance and take top 15
                 const sortedTaxa = Object.entries(counts).sort((a, b) => b[1] - a[1]);
                 const topTaxa = sortedTaxa.slice(0, 15);
                 const labels = topTaxa.map(item => item[0]);
                 const data = topTaxa.map(item => item[1]);
                 
                 // Beautiful gradient colors - blue to cyan spectrum
                 const colors = data.map((value, index) => {
                     const ratio = index / Math.max(data.length - 1, 1);
                     const r = Math.round(59 + (34 - 59) * ratio);   // 59 -> 34
                     const g = Math.round(130 + (211 - 130) * ratio); // 130 -> 211
                     const b = Math.round(246 + (238 - 246) * ratio); // 246 -> 238
                     return `rgba(${r}, ${g}, ${b}, 0.85)`;
                 });
                 
                 const borderColors = data.map((value, index) => {
                     const ratio = index / Math.max(data.length - 1, 1);
                     const r = Math.round(59 + (34 - 59) * ratio);
                     const g = Math.round(130 + (211 - 130) * ratio);
                     const b = Math.round(246 + (238 - 246) * ratio);
                     return `rgb(${r}, ${g}, ${b})`;
                 });
                 
                 const abundanceChartInstance = Chart.getChart('abundanceChart');
                 if(abundanceChartInstance) abundanceChartInstance.destroy();
                 
                 const ctx = document.getElementById('abundanceChart').getContext('2d');
                 Chart.defaults.font.family = "'Roboto Mono', monospace";
                 Chart.defaults.color = '#ffffff';
                 
                 new Chart(ctx, { 
                     type: 'bar', 
                     data: { 
                         labels: labels, 
                         datasets: [{ 
                             label: 'Abundance', 
                             data: data, 
                             backgroundColor: colors,
                             borderColor: borderColors,
                             borderWidth: 2,
                             borderRadius: 6,
                             borderSkipped: false
                         }] 
                     }, 
                     options: {
                         animation: {
                             duration: 1000,
                             easing: 'easeOutQuart'
                         },
                         indexAxis: 'y', 
                         responsive: true, 
                         maintainAspectRatio: true,
                         scales: { 
                             y: { 
                                 ticks: { 
                                     color: '#d1d5db', 
                                     font: {size: 10, weight: '500'},
                                     padding: 8,
                                     callback: function(value, index) {
                                         const label = this.getLabelForValue(value);
                                         if (label.length > 30) {
                                             return label.substring(0, 27) + '...';
                                         }
                                         return label;
                                     }
                                 }, 
                                 grid: { 
                                     display: false
                                 },
                                 border: {
                                     display: false
                                 }
                             }, 
                             x: { 
                                 ticks: { 
                                     color: '#9ca3af',
                                     font: {size: 10},
                                     stepSize: 1,
                                     precision: 0,
                                     callback: function(value) {
                                         // Only show integer values
                                         if (Number.isInteger(value)) {
                                             return value;
                                         }
                                         return null;
                                     }
                                 }, 
                                 grid: { 
                                     color: 'rgba(63, 63, 70, 0.3)',
                                     drawBorder: false
                                 },
                                 border: {
                                     display: false
                                 },
                                 title: { 
                                     display: true, 
                                     text: 'Number of Sequences', 
                                     color: '#9ca3af', 
                                     font: { size: 11, weight: '600' },
                                     padding: { top: 10 }
                                 },
                                 min: 0,
                                 beginAtZero: true
                             } 
                         }, 
                         plugins: { 
                             legend: { 
                                 display: false 
                             }, 
                             title: { 
                                 display: labels.length === 0, 
                                 text: 'No batch data to display', 
                                 color: '#6b7280', 
                                 font: {size: 12} 
                             },
                             tooltip: {
                                 backgroundColor: 'rgba(0, 0, 0, 0.95)',
                                 padding: 14,
                                 titleColor: '#fff',
                                 titleFont: { size: 13, weight: 'bold' },
                                 bodyColor: '#d1d5db',
                                 bodyFont: { size: 12 },
                                 borderColor: 'rgba(59, 130, 246, 0.5)',
                                 borderWidth: 2,
                                 cornerRadius: 8,
                                 displayColors: false,
                                 callbacks: {
                                     title: function(context) {
                                         return context[0].label;
                                     },
                                     label: function(context) {
                                         const count = context.parsed.x;
                                         const total = data.reduce((sum, val) => sum + val, 0);
                                         const percentage = ((count / total) * 100).toFixed(1);
                                         return [
                                             `Sequences: ${count}`,
                                             `Percentage: ${percentage}%`
                                         ];
                                     }
                                 }
                             }
                         },
                         layout: {
                             padding: {
                                 left: 5,
                                 right: 15,
                                 top: 10,
                                 bottom: 10
                             }
                         }
                     } 
                 });
            }

            function generateSummaryPdfReport(insights) {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: "portrait", unit: "mm", format: "a4" });

                const docWidth = doc.internal.pageSize.getWidth();
                const docHeight = doc.internal.pageSize.getHeight();
                const margin = 15;
                let yPos = margin;

                doc.setFont("helvetica", "bold");
                doc.setFontSize(20);
                doc.text("Ecological Insights Report", docWidth / 2, yPos, { align: "center" });
                yPos += 15;

                doc.setFontSize(10);
                doc.setFont("helvetica", "normal");
                const environment = document.getElementById('environmentType').value || 'Not Specified';
                const depth = document.getElementById('batchDepth').value || 'Not Specified';
                doc.text(`Environment: ${environment}`, margin, yPos);
                doc.text(`Depth: ${depth} meters`, docWidth - margin, yPos, { align: "right" });
                yPos += 6;
                doc.setLineWidth(0.2);
                doc.line(margin, yPos, docWidth - margin, yPos);
                yPos += 10;

                const renderSection = (item) => {
                    if (!item) return;
                     if (yPos > docHeight - 30) { 
                         doc.addPage();
                         yPos = margin;
                     }
                    doc.setFont("helvetica", "bold");
                    doc.setFontSize(12);
                    doc.text(item.title, margin, yPos);
                    yPos += 6;
                    doc.setFont("helvetica", "normal");
                    doc.setFontSize(10);
                    const lines = doc.splitTextToSize(item.insight, docWidth - margin * 2);
                    doc.text(lines, margin, yPos);
                    yPos += (lines.length * 5);

                    if (item.richness_value !== undefined) {
                         yPos += 2;
                         doc.text(`Taxa Richness: ${item.richness_value} | Evenness: ${item.evenness_category}`, margin, yPos);
                         yPos += 5;
                    }
                     if (item.protist_count !== undefined) {
                         const communityChartCanvas = document.getElementById('communityDonutChart');
                         if (communityChartCanvas) {
                             const communityChartImg = communityChartCanvas.toDataURL('image/png', 1.0);
                             if (yPos > docHeight - 60) {
                                 doc.addPage();
                                 yPos = margin;
                             }
                             doc.addImage(communityChartImg, 'PNG', docWidth / 2 - 25, yPos, 50, 50);
                             yPos += 55;
                         }
                     }
                    yPos += 8;
                };
               
                Object.values(insights).forEach(renderSection);

                const pageCount = doc.internal.getNumberOfPages();
                for(let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFontSize(10);
                    doc.setTextColor(150);
                    doc.text('Report by Bio-Line', docWidth / 2, docHeight - 10, { align: 'center' });
                }

                doc.save('Bio-Line-Summary-Report.pdf');
            }
           
            async function generateDetailedPdfReport() {
                modalButtons.classList.add('hidden');
                modalLoader.classList.remove('hidden');

                const apiKey = "AIzaSyDHT_bxYVMS5--RMVjEiCnKg9yGe73b-z8"; // Replace with your key if needed
                const environment = document.getElementById('environmentType').value || 'Not Specified';
                const depth = document.getElementById('batchDepth').value || 'Not Specified';
                
                // Calculate diversity metrics for the report
                const diversityMetrics = calculateDiversityMetrics(window.currentBatchResults || []);
                const metricsText = diversityMetrics ? `
**Diversity Metrics:**
- Species Richness (S): ${diversityMetrics.alpha.speciesRichness}
- Shannon Index (H'): ${diversityMetrics.alpha.shannonIndex}
- Simpson Index (D): ${diversityMetrics.alpha.simpsonIndex}
- Simpson Diversity (1-D): ${diversityMetrics.alpha.simpsonDiversity}
- Pielou's Evenness (J'): ${diversityMetrics.alpha.pielouEvenness}
- Total Individuals: ${diversityMetrics.totalIndividuals}
` : 'Metrics not available';

                const detailedPrompt = `
You are an expert marine biologist and bioinformatician tasked with creating a comprehensive, multi-page ecological report based on eDNA analysis data.

### CONTEXT
- **Platform:** Bio-Line AI Analysis
- **Sample Environment:** ${environment}
- **Sample Depth:** ${depth} meters
- **Analysis Type:** High-throughput eDNA sequencing with AI-powered taxonomic classification.

### DIVERSITY METRICS
${metricsText}

### INPUT DATA
- **Aggregated Community Data:** ${JSON.stringify(currentInsightsData)}
- **Individual Sequence Findings:** \`\`\`json
${JSON.stringify(detailedReportData.slice(0, 50))}
\`\`\`
(Note: Only the first 50 sequences are shown for brevity, but analyze the full dataset conceptually.)

### YOUR TASK
Generate a detailed, multi-page report as a single block of Markdown-formatted text. The report should be structured with the following sections using Markdown headings (#, ##, ###).

1.  **# Executive Summary:** A high-level overview of the findings, key insights, and primary recommendations. (Approx. 2 paragraphs)
2.  **# Introduction & Methodology:** Briefly explain eDNA metabarcoding. Describe the Bio-Line pipeline: data ingestion, marker gene extraction (COI and 18S rRNA), AI classification, and ecological insight generation. (Approx. 3-4 paragraphs)
3.  **# Biodiversity Assessment:**
    * **## Diversity Metrics Analysis:** Interpret the provided Shannon Index, Simpson Index, Pielou's Evenness values. Explain what these metrics reveal about the community structure and biodiversity.
    * **## Community Composition:** Analyze the overall community structure based on the aggregated data. Discuss the richness, evenness, and the major taxonomic groups found.
    * **## Dominant Taxa & Ecological Roles:** Identify the top 3-5 most abundant taxa from the data. For each, describe their known ecological roles (e.g., primary producer, grazer, predator, decomposer) and what their dominance suggests about the ecosystem.
4.  **# Detailed Findings:**
    * Create a Markdown table with the following columns for the first 15 sequences from the detailed data: "Sample ID", "Detected Gene", "Predicted Taxa".
5.  **# Analysis of Potential Threats & Conservation:**
    * Based on the identified taxa and specified environment (e.g., 'Hydrothermal Vent'), infer potential ecological threats. Consider general threats like climate change (ocean warming, acidification), pollution (microplastics, chemical), and potential localized threats (e.g., deep-sea mining if near vents).
    * Discuss how the presence or absence of certain bioindicator species in the data might point to these threats.
    * Provide 2-3 specific, actionable conservation recommendations based on your analysis.
6.  **# Conclusion:** Summarize the importance of these findings and suggest future research directions.

Ensure the language is scientific, professional, and accessible. The final output must be a single string of Markdown text.
`;
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: detailedPrompt }] }] }) });
                    if (!response.ok) throw new Error(`Gemini API Error (${response.status}): ${await response.text()}`);
                    const result = await response.json();
                    const markdownText = result.candidates[0].content.parts[0].text;
                   
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({ orientation: "portrait", unit: "mm", format: "a4" });
                    const docWidth = doc.internal.pageSize.getWidth();
                    const docHeight = doc.internal.pageSize.getHeight();
                    const margin = 15;
                    let yPos = 0;
                   
                    const addHeader = (text) => {
                        doc.setFont("helvetica", "bold");
                        doc.setFontSize(14);
                        doc.setTextColor(0,0,0);
                        doc.text(text, docWidth / 2, margin, { align: "center"});
                        yPos = margin + 15;
                    };

                    const addFooter = () => {
                        const pageCount = doc.internal.getNumberOfPages();
                        for(let i = 1; i <= pageCount; i++) {
                            doc.setPage(i);
                            doc.setLineWidth(0.2);
                            doc.setDrawColor(200);
                            doc.line(margin, docHeight - 18, docWidth - margin, docHeight - 18);
                            doc.setFontSize(9);
                            doc.setTextColor(100);
                            doc.text(`Report by Bio-Line // CMLRE Initiative`, margin, docHeight - 10);
                            doc.text(`Page ${i} of ${pageCount}`, docWidth - margin, docHeight - 10, { align: 'right' });
                        }
                    };

                    const checkPageBreak = (neededHeight) => {
                        if (yPos + neededHeight > docHeight - 25) {
                           doc.addPage();
                           yPos = margin;
                        }
                    };

                    addHeader("Detailed Ecological Insights Report");
                   
                    // Clean markdown text to remove formatting artifacts that cause ***text*** issues
                    const cleanedMarkdown = markdownText
                        .replace(/\*\*\*([^*]+)\*\*\*/g, '$1')  // Remove bold+italic ***text***
                        .replace(/\*\*([^*]+)\*\*/g, '$1')      // Remove bold **text**
                        .replace(/\*([^*]+)\*/g, '$1')          // Remove italic *text*
                        .replace(/__([^_]+)__/g, '$1')          // Remove bold __text__
                        .replace(/_([^_]+)_/g, '$1');           // Remove italic _text_
                   
                    const lines = cleanedMarkdown.split('\n');
                    for (const line of lines) {
                        let trimmedLine = line.trim();
                       
                        if (trimmedLine.startsWith('# ')) {
                            checkPageBreak(20);
                            yPos += 8;
                            doc.setFont("helvetica", "bold");
                            doc.setFontSize(16);
                            doc.setTextColor(0,0,0);
                            const text = trimmedLine.substring(2);
                            const splitText = doc.splitTextToSize(text, docWidth - margin * 2);
                            doc.text(splitText, margin, yPos);
                            yPos += (splitText.length * 7) + 2;
                            doc.setLineWidth(0.2);
                            doc.setDrawColor(200);
                            doc.line(margin, yPos-2, margin + 50, yPos-2);
                            yPos += 5;

                        } else if (trimmedLine.startsWith('## ')) {
                            checkPageBreak(15);
                            yPos += 6;
                            doc.setFont("helvetica", "bold");
                            doc.setFontSize(12);
                             doc.setTextColor(50,50,50);
                            const text = trimmedLine.substring(3);
                            const splitText = doc.splitTextToSize(text, docWidth - margin * 2);
                            doc.text(splitText, margin, yPos);
                            yPos += (splitText.length * 6) + 4;

                        } else if (trimmedLine.startsWith('* ') || trimmedLine.startsWith('- ')) {
                             checkPageBreak(8);
                             doc.setFont("helvetica", "normal");
                             doc.setFontSize(10);
                             doc.setTextColor(0,0,0);
                             const text = trimmedLine.substring(2);
                             const splitText = doc.splitTextToSize(text, docWidth - (margin * 2) - 5);
                             doc.text("•", margin, yPos + 1, { baseline: 'top' });
                             doc.text(splitText, margin + 5, yPos);
                             yPos += (splitText.length * 5) + 2;
                       
                        } else if (trimmedLine.startsWith('|')) {
                            checkPageBreak(5);
                            doc.setFont("courier", "normal");
                            doc.setFontSize(8);
                            doc.setTextColor(80,80,80);
                            doc.text(trimmedLine.replace(/\|/g, '  '), margin, yPos);
                            yPos += 4;

                        } else if (trimmedLine.length > 0) {
                            checkPageBreak(10);
                            doc.setFont("helvetica", "normal");
                            doc.setFontSize(10);
                            doc.setTextColor(0,0,0);
                            const splitText = doc.splitTextToSize(trimmedLine, docWidth - margin * 2);
                            doc.text(splitText, margin, yPos);
                            yPos += (splitText.length * 5) + 3;
                        }

                        if (trimmedLine.toLowerCase().includes('## community composition')) {
                            const abundanceChartCanvas = document.getElementById('abundanceChart');
                            if(abundanceChartCanvas) {
                                const abundanceChartImg = abundanceChartCanvas.toDataURL('image/png', 1.0);
                                checkPageBreak(80);
                                yPos += 5;
                                doc.addImage(abundanceChartImg, 'PNG', margin, yPos, docWidth - (margin * 2), 70);
                                yPos += 75;
                                doc.setFontSize(8);
                                doc.setTextColor(150);
                                doc.text('Figure 1: Top 15 most abundant taxa identified in the sample.', docWidth / 2, yPos, {align: 'center'});
                                yPos += 10;
                            }
                        }
                        if(currentInsightsData.community_structure && trimmedLine.toLowerCase().includes('## community composition')) {
                            const communityChartCanvas = document.getElementById('communityDonutChart');
                            if(communityChartCanvas) {
                                // Temporarily change chart legend color to black for PDF export
                                const chart = Chart.getChart('communityDonutChart');
                                const originalLegendColor = chart.options.plugins.legend.labels.color;
                                chart.options.plugins.legend.labels.color = '#000000';
                                chart.options.plugins.legend.labels.generateLabels = function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        return data.labels.map((label, i) => {
                                            const meta = chart.getDatasetMeta(0);
                                            const value = data.datasets[0].data[i];
                                            const total = data.datasets[0].data.reduce((a, b) => a + b, 0);
                                            const percentage = ((value / total) * 100).toFixed(1);
                                            return {
                                                text: `${label} (${percentage}%)`,
                                                fillStyle: data.datasets[0].backgroundColor[i],
                                                strokeStyle: data.datasets[0].borderColor[i],
                                                lineWidth: 2,
                                                fontColor: '#000000',  // Black for PDF
                                                hidden: !meta.data[i] || meta.data[i].hidden,
                                                index: i
                                            };
                                        });
                                    }
                                    return [];
                                };
                                chart.update();
                                
                                // Export to PDF
                                const communityChartImg = communityChartCanvas.toDataURL('image/png', 1.0);
                                checkPageBreak(80);
                                yPos += 5;
                                doc.addImage(communityChartImg, 'PNG', docWidth / 2 - 40, yPos, 80, 80);
                                yPos += 85;
                                doc.setFontSize(8);
                                doc.setTextColor(150);
                                doc.text('Figure 2: Proportional abundance of Protista vs. Metazoa.', docWidth / 2, yPos, {align: 'center'});
                                yPos += 10;
                                
                                // Restore original color for UI
                                chart.options.plugins.legend.labels.color = originalLegendColor;
                                chart.options.plugins.legend.labels.generateLabels = function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        return data.labels.map((label, i) => {
                                            const meta = chart.getDatasetMeta(0);
                                            const value = data.datasets[0].data[i];
                                            const total = data.datasets[0].data.reduce((a, b) => a + b, 0);
                                            const percentage = ((value / total) * 100).toFixed(1);
                                            return {
                                                text: `${label} (${percentage}%)`,
                                                fillStyle: data.datasets[0].backgroundColor[i],
                                                strokeStyle: data.datasets[0].borderColor[i],
                                                lineWidth: 2,
                                                fontColor: '#ffffff',  // White for UI
                                                hidden: !meta.data[i] || meta.data[i].hidden,
                                                index: i
                                            };
                                        });
                                    }
                                    return [];
                                };
                                chart.update();
                            }
                        }
                    }

                    addFooter();
                    doc.save('Bio-Line-Detailed-Report.pdf');

                } catch (error) {
                    alert("Failed to generate detailed report: " + error.message);
                } finally {
                    modalButtons.classList.remove('hidden');
                    modalLoader.classList.add('hidden');
                    reportModal.classList.add('hidden');
                }
            }

            // --- Chatbot Logic ---
            if (chatBtn) {
                chatBtn.addEventListener('click', () => {
                chatbotContainer.classList.remove('hidden');
                if (chatMessages.children.length === 0) {
                    appendMessage("Hello! I'm the Bio-Line AI assistant. How can I help you interpret these ecological insights?", 'bot');
                }
                });
            }

            if (closeChatbotBtn) {
                closeChatbotBtn.addEventListener('click', () => {
                    if (chatbotContainer) chatbotContainer.classList.add('hidden');
                });
            }

            if (chatForm) {
                chatForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const userInput = chatInput.value.trim();
                if (!userInput) return;

                appendMessage(userInput, 'user');
                chatInput.value = '';
                appendMessage('...', 'bot', true); // Thinking indicator

                try {
                    const botResponse = await askGeminiForChat(userInput);
                    const thinkingIndicator = document.getElementById('thinking');
                    if (thinkingIndicator) thinkingIndicator.parentElement.remove();
                    appendMessage(botResponse, 'bot');
                } catch (error) {
                    console.error("Chatbot API call failed:", error);
                    const thinkingIndicator = document.getElementById('thinking');
                    if (thinkingIndicator) thinkingIndicator.parentElement.remove();
                    appendMessage("Sorry, I encountered an error. Please try again.", 'bot');
                }
                });
            }

            function appendMessage(text, sender, isThinking = false) {
                const messageWrapper = document.createElement('div');
                messageWrapper.className = `flex w-full ${sender === 'user' ? 'justify-end' : 'justify-start'}`;

                const messageElement = document.createElement('div');
                messageElement.className = `max-w-xs md:max-w-md p-3 rounded-lg text-sm`;

                if (sender === 'user') {
                    messageElement.classList.add('bg-white', 'text-black');
                } else {
                    messageElement.classList.add('bg-[#18181b]', 'text-gray-300', 'border', 'border-[#27272a]');
                }
               
                if (isThinking) {
                    messageElement.id = 'thinking';
                    messageElement.innerHTML = `<div class="flex items-center space-x-1 p-1">
                        <div class="w-2 h-2 bg-gray-500 rounded-full animate-pulse" style="animation-delay: 0s;"></div>
                        <div class="w-2 h-2 bg-gray-500 rounded-full animate-pulse" style="animation-delay: 0.2s;"></div>
                        <div class="w-2 h-2 bg-gray-500 rounded-full animate-pulse" style="animation-delay: 0.4s;"></div>
                    </div>`;
                } else {
                    text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    messageElement.innerHTML = text;
                }
               
                messageWrapper.appendChild(messageElement);
                chatMessages.appendChild(messageWrapper);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            async function askGeminiForChat(question) {
                if (!currentInsightsData) {
                    return "The ecological insights data isn't available. Please run a batch analysis first.";
                }

                const apiKey = "AIzaSyDHT_bxYVMS5--RMVjEiCnKg9yGe73b-z8"; // Replace with your key if needed
                const systemPrompt = `You are a helpful and friendly AI assistant for the Bio-Line platform, specializing in marine ecology. Your name is "Bio-Line Assistant".
                Your primary task is to answer questions based on the provided JSON data from an eDNA analysis.
                - First, always try to answer using the **provided JSON data context**.
                - If the question is a general knowledge question related to biology or ecology (like defining a term or giving examples of a phylum) and the answer is not in the JSON, you are allowed to use your general knowledge to provide a helpful, accurate answer.
                - When answering from general knowledge, be clear that this information is not from the specific sample analysis. For example, start with "Generally speaking,..." or "While not detailed in this specific analysis,...".
                - If the user asks a question completely unrelated to the analysis or ecology, politely decline to answer.
                - Keep your answers concise and easy to understand for a scientist.
                - You can use markdown for formatting, like using **bold** text to highlight key terms.`;
               
                const userPrompt = `CONTEXT DATA:
                \`\`\`json
                ${JSON.stringify(currentInsightsData, null, 2)}
                \`\`\`
                QUESTION:
                ${question}`;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: userPrompt }] }],
                        tools: [{ "google_search": {} }],
                        systemInstruction: { parts: [{ text: systemPrompt }] }
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Chatbot Gemini API Error (${response.status}): ${errorText}`);
                }

                const result = await response.json();
                if (!result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    throw new Error("Invalid response structure from Chatbot Gemini API.");
                }

                return result.candidates[0].content.parts[0].text;
            }

            // Modal listeners
            generateReportBtn.addEventListener('click', () => {
                reportModal.classList.remove('hidden');
            });
            closeModalBtn.addEventListener('click', () => {
                reportModal.classList.add('hidden');
            });
            downloadSummaryReportBtn.addEventListener('click', () => {
                if (currentInsightsData) {
                    generateSummaryPdfReport(currentInsightsData);
                }
                 reportModal.classList.add('hidden');
            });
            downloadDetailedReportBtn.addEventListener('click', () => {
                generateDetailedPdfReport();
            });

        });
    </script>
</body>
</html>