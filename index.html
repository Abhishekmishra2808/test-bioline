<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio-Line // CMLRE Initiative</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="database_search.js"></script>
    <!-- Leaflet for maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet.heat for heatmap -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #e5e7eb;
            --grid-color: rgba(255, 255, 255, 0.07);
            background-image:
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 30px 30px;
        }
        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }

        /* --- MODIFICATION 1: Position the Spline model as a background element on the right --- */
       spline-viewer {
            position: fixed; /* Fixed position relative to the viewport */
            top: 0;
            right: 0;
            width: 50vw; /* Occupies the right half of the screen */
            height: 100vh;
            z-index: 0; /* Sits behind the content */
            transform: scale(2.5); /* --- MODIFICATION: "Super zoom" the model by 2.5x --- */
            transform-origin: center; /* Ensure it zooms from the center */
            transition: opacity 0.3s ease; /* Smooth transition when hiding */
            
            /* * --- MODIFICATION: Enable Model Interaction --- 
             * The 'pointer-events: none;' property has been removed.
             * This allows mouse events (like scrolling to zoom, clicking, and dragging)
             * to be captured by the Spline model instead of passing through it.
             * Now, you can interact with the 3D model directly.
            */
        }


        .content-wrapper {
            position: relative;
            z-index: 1; /* Ensures content is on top of the spline model */
        }
        .card {
            background-color: rgba(26, 26, 26, 0.6);
            border: 1px solid #3f3f46;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }
        .btn-primary {
            background-color: transparent;
            color: #ffffff;
            transition: all 0.3s ease;
            border: 1px solid #ffffff;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        .btn-primary:hover {
            background-color: #ffffff;
            color: #000000;
        }
        .btn-primary:disabled {
            color: #6b7280;
            border-color: #3f3f46;
            background-color: transparent;
            cursor: not-allowed;
        }
        .btn-secondary {
            background-color: transparent;
            color: #a1a1aa;
            border: 1px solid #3f3f46;
        }
        .btn-secondary:hover {
             background-color: #27272a;
             color: #ffffff;
        }
        .reveal {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s ease-out, transform 0.8s ease-out;
        }
        .reveal.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .section-title {
            color: #ffffff;
            font-size: 1rem;
            font-weight: 500;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            font-family: 'Roboto Mono', monospace;
        }
        .line {
            height: 1px;
            background-color: #27272a;
            flex-grow: 1;
        }
        .text-scramble {
            display: inline-block;
        }
        .blinking-cursor {
            color: white;
            animation: blink 1s step-end infinite;
        }
        @keyframes blink {
            50% { opacity: 0; }
        }
        #reportModal.hidden, #chatbot-container.hidden {
            display: none;
        }
        
        /* Custom scrollbar for results table */
        #classificationResult::-webkit-scrollbar {
            height: 6px;
        }
        #classificationResult::-webkit-scrollbar-track {
            background: #000;
        }
        #classificationResult::-webkit-scrollbar-thumb {
            background: #27272a;
            border-radius: 3px;
        }
        #classificationResult::-webkit-scrollbar-thumb:hover {
            background: #3f3f46;
        }
        
        /* Force Chart.js canvas text to be white */
        canvas {
            color: #ffffff !important;
        }
    </style>
</head>

<body class="antialiased">
    <script type="module" src="https://unpkg.com/@splinetool/viewer@1.10.68/build/spline-viewer.js"></script>
    <spline-viewer url="https://prod.spline.design/j-bDax7HxMeYiO4s/scene.splinecode"></spline-viewer>

    <div class="content-wrapper">
        <div id="homePage">
            <header class="fixed top-0 left-0 right-0 z-50">
                <nav class="container mx-auto px-6 py-4 flex justify-between items-center border-b border-gray-800 bg-black/50 backdrop-blur-md">
                    <div class="text-lg font-bold text-white tracking-widest"><a href="#">Bio-Line</a></div>
                    <div class="hidden md:flex items-center space-x-8 text-sm uppercase font-mono">
                        <a href="#problem" class="text-gray-400 hover:text-white transition">01_Problem</a>
                        <a href="#solution" class="text-gray-400 hover:text-white transition">02_Solution</a>
                        <a href="#tech" class="text-gray-400 hover:text-white transition">03_System</a>
                    </div>
                    <button id="loginBtn" class="btn-primary font-medium py-2 px-4 text-xs font-mono">Engage Platform</button>
                </nav>
            </header>
            <main class="container mx-auto px-6">
                <section class="min-h-screen flex flex-col justify-center items-start pt-20">
                    <div class="w-full lg:w-1/2">
                        <div class="text-left">
                            <h1 class="text-3xl md:text-5xl font-bold text-white leading-tight mb-4 font-mono">
                                <span class="text-scramble" data-text="AI-DRIVEN eDNA ANALYSIS"></span>
                                <span class="blinking-cursor">_</span>
                            </h1>
                            <p class="text-base text-gray-400 mb-8 max-w-lg">
                                A high-throughput pipeline to classify eukaryotic taxa and assess deep-sea biodiversity directly from raw environmental DNA, bypassing the limitations of conventional reference databases.
                            </p>
                            <div class="flex flex-wrap items-center gap-4">
                                <a href="#problem" class="btn-primary font-semibold py-3 px-6 text-sm">View Mission Brief</a>
                                <a href="https://youtu.be/i7P405rwkt0" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 text-sm rounded transition-all duration-300 group">
                                    <svg class="w-5 h-5 group-hover:scale-110 transition-transform" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                                    </svg>
                                    Watch Live Demo
                                </a>
                            </div>
                        </div>
                    </div>
                </section>
                 <section id="problem" class="py-24">
                     <div data-reveal class="flex items-center gap-4 mb-12"><span class="section-title text-gray-500">01</span><span class="section-title">Problem Statement</span><div class="line"></div></div>
                     <div class="grid md:grid-cols-2 gap-8">
                         <div class="card p-8 reveal rounded-lg" data-reveal><h3 class="text-xl font-bold text-white mb-4">// Incomplete Databases</h3><p class="text-gray-400">Deep-sea organisms are critically underrepresented in genetic reference databases. This data void results in misclassification, unassigned reads, and a fundamental underestimation of true biodiversity.</p></div>
                         <div class="card p-8 reveal rounded-lg" data-reveal style="transition-delay: 150ms"><h3 class="text-xl font-bold text-white mb-4">// Computational Bottlenecks</h3><p class="text-gray-400">Legacy bioinformatic pipelines are computationally expensive and inefficient for novel discovery. Their reliance on sequence alignment against flawed databases is a primary limiting factor.</p></div>
                     </div>
                 </section>
                
                 <section id="solution" class="py-24">
                     <div data-reveal class="flex items-center gap-4 mb-12"><span class="section-title text-gray-500">02</span><span class="section-title">Proposed Solution</span><div class="line"></div></div>
                     <div class="grid grid-cols-1 gap-8">
                         <div class="card p-8 md:p-12 reveal rounded-lg" data-reveal>
                            <p class="text-base text-gray-300 leading-relaxed">Our AI-driven pipeline leverages deep learning and unsupervised clustering to analyze eDNA without primary reliance on existing databases. The system is designed to:</p>
                             <ul class="mt-8 space-y-6 text-sm">
                                 <li class="flex items-start"><span class="text-white mr-4 mt-1 font-mono">[+]</span><span><strong class="text-white font-semibold">CLASSIFY TAXA DIRECTLY:</strong> A fine-tuned DNA-BERT transformer model interprets raw sequence data, enabling classification without perfect database matches.</span></li>
                                 <li class="flex items-start"><span class="text-white mr-4 mt-1 font-mono">[+]</span><span><strong class="text-white font-semibold">DISCOVER NOVEL SPECIES:</strong> Unsupervised clustering algorithms (DBSCAN, k-means) identify and group unknown sequences, flagging potential new taxa for targeted analysis.</span></li>
                                  <li class="flex items-start"><span class="text-white mr-4 mt-1 font-mono">[+]</span><span><strong class="text-white font-semibold">GENERATE ECOLOGICAL INSIGHTS:</strong> Rapidly produce accurate estimations of species abundance and community structure to inform conservation and research priorities.</span></li>
                             </ul>
                         </div>
                     </div>
                 </section>

                 <section id="tech" class="py-24">
                     <div data-reveal class="flex items-center gap-4 mb-12"><span class="section-title text-gray-500">03</span><span class="section-title">System Architecture</span><div class="line"></div></div>
                     <div class="card p-8 flex justify-center items-center reveal rounded-lg" data-reveal>
                        <p class="text-center text-gray-400 max-w-4xl text-sm font-mono">SYSTEM INGESTS RAW eDNA DATA -> PREPROCESSING MODULE EXTRACTS 18S rRNA & COI MARKERS -> DATA IS VECTORIZED BY A FINE-TUNED DNA-BERT TRANSFORMER -> EMBEDDINGS ARE PROCESSED VIA DUAL PATHWAYS: [A] DEEP LEARNING FOR CLASSIFICATION, [B] UNSUPERVISED CLUSTERING FOR NOVELTY DETECTION -> OUTPUT GENERATION: TAXONOMIC GROUPING, ABUNDANCE ESTIMATION, ECOLOGICAL INSIGHTS.</p>
                     </div>
                 </section>
                 <div class="h-24"></div>
            </main>
        </div>

        <div id="loginPage" class="hidden min-h-screen flex items-center justify-center p-4">
               <div class="w-full max-w-sm">
                       <div class="card p-8 space-y-6 border border-[#27272a] rounded-lg">
                           <h2 class="text-lg font-bold text-center text-white tracking-widest font-mono">// AUTHENTICATION REQUIRED</h2>
                           <div>
                               <div class="flex border border-[#27272a] rounded-md overflow-hidden"><button id="userToggle" class="w-1/2 py-2 text-sm font-medium bg-white text-black">USER</button><button id="adminToggle" class="w-1/2 py-2 text-sm font-medium text-gray-400">ADMIN</button></div>
                           </div>
                           <form id="loginForm" class="space-y-4">
                               <div><label for="email" class="text-xs font-medium text-gray-400 font-mono">EMAIL_ADDR</label><input type="email" id="email" class="w-full mt-1 p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white focus:border-white outline-none text-sm" value="user@cmlre.gov"></div>
                               <div><label for="password" class="text-xs font-medium text-gray-400 font-mono">PASSWORD</label><input type="password" id="password" class="w-full mt-1 p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white focus:border-white outline-none" value="password"></div>
                               <button type="submit" class="w-full btn-primary font-bold py-3 px-4 text-xs rounded-md">EXECUTE LOGIN</button>
                           </form>
                       </div>
               </div>
        </div>

        <div id="dashboardPage" class="hidden min-h-screen container mx-auto px-6 py-24">
            <div class="flex justify-between items-center mb-8 border-b border-[#27272a] pb-4">
                <h1 class="text-xl font-bold text-white tracking-widest font-mono">// ANALYSIS DASHBOARD</h1>
                <button id="logoutBtn" class="text-gray-400 hover:text-white transition text-xs uppercase font-mono">LOGOUT</button>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
                <div class="card p-6 border border-[#27272a] rounded-lg">
                    <h2 class="text-lg font-semibold text-white mb-4 font-mono">// SINGLE SEQUENCE ANALYSIS</h2>
                    <textarea id="dnaSequenceInput" rows="4" class="w-full p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white outline-none text-sm font-mono" placeholder="> Paste raw eDNA sequence here..."></textarea>
                    <div class="mt-4 text-right">
                        <button id="analyzeBtn" class="btn-primary font-bold py-2 px-5 text-xs rounded-md">INITIATE ANALYSIS</button>
                    </div>
                </div>
                <div class="card p-6 border border-[#27272a] rounded-lg">
                    <h2 class="text-lg font-semibold text-white mb-4 font-mono">// BATCH ANALYSIS (CSV/FASTA)</h2>
                    <p class="text-xs text-gray-400 mb-2">Upload a CSV file with 'sample_id' and 'sequence' columns, or a FASTA file with sequences.</p>
                    
                    <!-- Format Examples -->
                    <details class="mb-2">
                        <summary class="text-xs text-blue-400 cursor-pointer hover:text-blue-300 transition">View format examples</summary>
                        <div class="mt-2 p-3 bg-black/50 border border-gray-800 rounded text-xs font-mono space-y-3">
                            <div>
                                <div class="text-gray-400 mb-1">CSV Format:</div>
                                <code class="text-green-400 block">sample_id,sequence<br>sample_1,ATCGATCGATCG<br>sample_2,GCTAGCTAGCTA</code>
                            </div>
                            <div>
                                <div class="text-gray-400 mb-1">FASTA Format:</div>
                                <code class="text-green-400 block">>sample_1<br>ATCGATCGATCG<br>>sample_2<br>GCTAGCTAGCTA</code>
                            </div>
                        </div>
                    </details>
                    
                    <!-- Download Sample Files -->
                    <details class="mb-4">
                        <summary class="text-xs text-blue-400 cursor-pointer hover:text-blue-300 transition">Download sample</summary>
                        <div class="mt-2 p-3 bg-black/50 border border-gray-800 rounded text-xs space-y-2">
                            <div>
                                <a href="sample_sequences.csv" download class="text-blue-400 hover:text-blue-300 transition cursor-pointer">sample.csv (15 sequences)</a>
                            </div>
                            <div>
                                <a href="sample_sequences.fasta" download class="text-blue-400 hover:text-blue-300 transition cursor-pointer">sample.fasta (15 sequences)</a>
                            </div>
                        </div>
                    </details>
                    
                    <input type="file" id="csvFileInput" class="hidden" accept=".csv,.fasta,.fa,.fna,.txt">
                    <button id="csvUploadBtn" class="w-full border border-dashed border-[#27272a] hover:border-white transition py-4 text-gray-400 text-sm rounded-md">
                        CLICK TO UPLOAD CSV/FASTA FILE
                    </button>
                   
                    <div class="mt-4 space-y-3">
                        <div>
                            <label for="environmentType" class="text-xs font-medium text-gray-400 font-mono">ENVIRONMENT TYPE</label>
                            <input type="text" id="environmentType" placeholder="e.g. Hydrothermal Vent" class="w-full mt-1 p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white focus:border-white outline-none text-sm">
                        </div>
                        <div>
                            <label for="batchDepth" class="text-xs font-medium text-gray-400 font-mono">DEPTH (meters)</label>
                            <input type="number" id="batchDepth" step="1" placeholder="e.g. 2500" class="w-full mt-1 p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white focus:border-white outline-none text-sm">
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label for="sampleLatitude" class="text-xs font-medium text-gray-400 font-mono">LATITUDE</label>
                                <input type="number" id="sampleLatitude" step="0.000001" placeholder="e.g. 20.5937" class="w-full mt-1 p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white focus:border-white outline-none text-sm">
                            </div>
                            <div>
                                <label for="sampleLongitude" class="text-xs font-medium text-gray-400 font-mono">LONGITUDE</label>
                                <input type="number" id="sampleLongitude" step="0.000001" placeholder="e.g. 88.2636" class="w-full mt-1 p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white focus:border-white outline-none text-sm">
                            </div>
                        </div>
                    </div>
                   
                    <div class="mt-4 text-right">
                        <button id="batchAnalyzeBtn" class="btn-primary font-bold py-2 px-5 text-xs rounded-md" disabled>ANALYZE BATCH</button>
                    </div>
                </div>
            </div>

            <div id="resultsSection" class="hidden">
                 <div class="mb-8 card border border-[#27272a] p-4 rounded-lg">
                     <h3 class="text-lg font-semibold text-white mb-4 font-mono">// PIPELINE STATUS</h3>
                     <div id="pipelineStatus" class="text-xs font-mono"></div>
                 </div>

                 <div id="markerResultsCard" class="hidden mb-8 card border border-[#27272a] p-6 rounded-lg">
                     <h3 class="text-lg font-semibold text-white mb-4 font-mono">// GENE MARKER DETECTION</h3>
                     <div id="markerResultsContent"></div>
                 </div>

                <!-- Diversity Metrics Card -->
                <div id="diversityMetricsCard" class="hidden mb-8 card border border-[#27272a] p-6 rounded-lg">
                    <h3 class="text-lg font-semibold text-white mb-4 font-mono">// DIVERSITY METRICS</h3>
                    <div id="diversityMetricsContent"></div>
                </div>

                <!-- Geographic Heatmap Card -->
                <div id="heatmapCard" class="hidden mb-8 card border border-[#27272a] p-6 rounded-lg">
                    <div class="mb-4">
                        <h3 class="text-lg font-semibold text-white font-mono">// GEOGRAPHIC DISTRIBUTION HEATMAP</h3>
                        <p class="text-gray-400 text-xs mt-2">Spatial distribution of identified taxa based on collection coordinates</p>
                    </div>
                    <div id="heatmapContainer" class="bg-black/50 rounded-lg overflow-hidden" style="height: 500px; border: 1px solid #27272a;"></div>
                    <div id="heatmapLegend" class="mt-4 p-4 bg-black/30 border border-[#27272a] rounded-lg">
                        <div class="text-xs text-gray-400 mb-2 font-semibold">LEGEND</div>
                        <div class="flex items-center gap-4 flex-wrap">
                            <div class="flex items-center gap-2">
                                <div class="w-4 h-4 rounded-full" style="background: radial-gradient(circle, rgba(255,0,0,0.8) 0%, rgba(255,0,0,0) 70%);"></div>
                                <span class="text-xs text-gray-400">High Density</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="w-4 h-4 rounded-full" style="background: radial-gradient(circle, rgba(255,255,0,0.8) 0%, rgba(255,255,0,0) 70%);"></div>
                                <span class="text-xs text-gray-400">Medium Density</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="w-4 h-4 rounded-full" style="background: radial-gradient(circle, rgba(0,255,0,0.8) 0%, rgba(0,255,0,0) 70%);"></div>
                                <span class="text-xs text-gray-400">Low Density</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Clustering Analysis Card -->
                <div id="clusteringCard" class="hidden mb-8 card border border-[#27272a] p-6 rounded-lg">
                    <div class="mb-4">
                        <h3 class="text-lg font-semibold text-white font-mono">// ORGANISM CLUSTERING ANALYSIS</h3>
                        <p class="text-gray-400 text-xs mt-2">Taxonomic relationships visualized using 2D UMAP clustering</p>
                    </div>
                    <div id="clusteringContent">
                        <div id="clusteringResults" class="hidden">
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                                <!-- Stat Cards -->
                                <div class="bg-gradient-to-br from-blue-500/10 to-blue-600/5 border border-blue-500/30 rounded-lg p-4">
                                    <div class="text-xs text-blue-400 uppercase tracking-wider mb-1">Total Clusters</div>
                                    <div class="text-3xl font-bold text-white" id="totalClustersCount">0</div>
                                </div>
                                <div class="bg-gradient-to-br from-green-500/10 to-green-600/5 border border-green-500/30 rounded-lg p-4">
                                    <div class="text-xs text-green-400 uppercase tracking-wider mb-1">Clustered</div>
                                    <div class="text-3xl font-bold text-white" id="clusteredCount">0</div>
                                </div>
                                <div class="bg-gradient-to-br from-yellow-500/10 to-yellow-600/5 border border-yellow-500/30 rounded-lg p-4">
                                    <div class="text-xs text-yellow-400 uppercase tracking-wider mb-1">Novel/Outliers</div>
                                    <div class="text-3xl font-bold text-white" id="novelClusterCount">0</div>
                                </div>
                            </div>
                            
                            <!-- Cluster Scatter Plot -->
                            <div class="mb-6">
                                <h4 class="text-sm font-semibold text-white mb-3 font-mono">Cluster Distribution (2D UMAP)</h4>
                                <div class="bg-black/50 p-4 rounded-lg border border-[#27272a]">
                                    <canvas id="clusterScatterChart" height="300"></canvas>
                                </div>
                            </div>
                            
                            <!-- Cluster Details -->
                            <div id="clusterDetails" class="space-y-3"></div>
                        </div>
                    </div>
                </div>

                <!-- Taxonomic Classification Results - Full Width -->
                <div class="mb-8 card p-6 border border-[#27272a] rounded-lg">
                    <div class="flex justify-between items-center flex-wrap gap-2 mb-4">
                        <h3 class="text-lg font-semibold text-white font-mono">// TAXONOMIC CLASSIFICATION RESULTS</h3>
                        <div class="flex items-center gap-2">
                            <button id="verifyDatabaseBtn" class="hidden btn-secondary font-bold py-2 px-4 text-xs rounded-md">
                                üîç Verify Novel Species
                            </button>
                            <button id="exportResultsBtn" class="hidden btn-secondary font-bold py-2 px-4 text-xs rounded-md">Export CSV</button>
                        </div>
                    </div>
                    <div id="classificationResult" class="text-sm">
                        <p class="text-gray-500">Results will appear here after analysis.</p>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <div class="lg:col-span-2 space-y-8">
                        <div id="insightsCard" class="card p-6 border border-[#27272a] rounded-lg">
                             <div class="flex justify-between items-center flex-wrap gap-2 mb-4">
                                 <h3 class="text-lg font-semibold text-white font-mono">// ECOLOGICAL INSIGHTS REPORT</h3>
                                 <div class="flex items-center gap-2">
                                     <button id="chatBtn" class="hidden btn-secondary font-bold py-2 px-5 text-xs rounded-md">Chat with AI</button>
                                     <button id="generateReportBtn" class="hidden btn-primary font-bold py-2 px-5 text-xs rounded-md">Generate Report</button>
                                 </div>
                             </div>
                            <div id="insightsResult" class="space-y-6 text-sm">
                                <p class="text-gray-500">Ecological insights will be generated after batch analysis is complete.</p>
                            </div>
                        </div>
                    </div>
                    <div class="space-y-8">
                        <div class="card p-6 border border-[#27272a] rounded-lg">
                            <h3 class="text-lg font-semibold text-white mb-4 font-mono">// TAXA ABUNDANCE</h3>
                            <canvas id="abundanceChart"></canvas>
                        </div>
                        <div class="card p-6 border border-[#27272a] rounded-lg">
                            <h3 class="text-lg font-semibold text-white mb-4 font-mono">// NOVELTY DETECTION</h3>
                            <div id="noveltyResult" class="text-sm p-4 bg-black border border-[#27272a] rounded-md"></div>
                        </div>
                    </div>
                </div>
            </div>
             <div class="h-24"></div>
        </div>
    </div>
   
    <div id="reportModal" class="hidden fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4">
        <div class="card w-full max-w-md p-6 text-center border border-[#27272a] rounded-lg">
             <h2 class="text-lg font-bold text-white mb-4 font-mono">// Select Report Type</h2>
             <p class="text-sm text-gray-400 mb-6">Choose the type of report you would like to generate and download.</p>
             <div id="modal-loader" class="hidden mb-4">
                 <div class="flex justify-center items-center space-x-2">
                     <svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                     <span class="text-sm text-gray-400">Generating detailed report... this may take a moment.</span>
                 </div>
             </div>
             <div id="modal-buttons" class="space-y-4">
                 <button id="downloadSummaryReportBtn" class="w-full btn-primary font-bold py-3 text-sm rounded-md">Download Summary Report</button>
                 <button id="downloadDetailedReportBtn" class="w-full btn-secondary font-bold py-3 text-sm rounded-md">Download Detailed Report</button>
             </div>
             <button id="closeModalBtn" class="mt-6 text-sm text-gray-500 hover:text-white">Cancel</button>
        </div>
    </div>
    
    <!-- Disclaimer Modal -->
    <div id="disclaimerModal" class="hidden fixed inset-0 bg-black bg-opacity-80 z-[200] flex items-center justify-center p-4">
        <div class="card w-full max-w-lg p-8 border border-yellow-500/50 rounded-lg relative overflow-hidden">
            <!-- Warning stripe decoration -->
            <div class="absolute top-0 left-0 right-0 h-1 bg-gradient-to-r from-yellow-500 via-orange-500 to-yellow-500"></div>
            
            <!-- Warning icon -->
            <div class="flex justify-center mb-4">
                <div class="w-16 h-16 bg-yellow-500/20 rounded-full flex items-center justify-center">
                    <svg class="w-10 h-10 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                    </svg>
                </div>
            </div>
            
            <h2 class="text-xl font-bold text-center text-yellow-400 mb-4 font-mono">// DEMO MODE NOTICE</h2>
            
            <div class="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4 mb-6">
                <p class="text-gray-300 text-sm leading-relaxed text-center">
                    The results displayed are currently based on <span class="text-yellow-400 font-semibold">mock data</span> and are <span class="text-yellow-400 font-semibold">not generated by trained Transformer-based models</span>.
                </p>
                <p class="text-gray-400 text-sm mt-3 text-center">
                    Real-time model deployment is temporarily disabled due to <span class="text-orange-400">high GPU inference costs</span>.
                </p>
            </div>
            
            <div class="flex flex-col items-center gap-4">
                <a href="https://youtu.be/i7P405rwkt0" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 text-sm rounded-lg transition-all duration-300 group">
                    <svg class="w-5 h-5 group-hover:scale-110 transition-transform" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                    </svg>
                    Watch Live Demo on YouTube
                </a>
                
                <button id="closeDisclaimerBtn" class="btn-primary font-bold py-3 px-8 text-sm rounded-lg">
                    I Understand, Continue to Demo
                </button>
            </div>
            
            <p class="text-gray-500 text-xs text-center mt-4">
                This demo showcases the platform's capabilities with simulated data.
            </p>
        </div>
    </div>
   
    <div id="chatbot-container" class="hidden fixed bottom-5 right-5 w-full max-w-sm h-[600px] z-[100] flex flex-col card p-0 overflow-hidden shadow-2xl border border-[#27272a] rounded-lg">
        <div class="flex justify-between items-center p-4 border-b border-[#27272a] bg-black/80">
            <h3 class="font-bold text-white font-mono">// AI Ecologist Assistant</h3>
            <button id="closeChatbotBtn" class="text-gray-500 hover:text-white">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
            </button>
        </div>
        <div id="chat-messages" class="flex-1 p-4 overflow-y-auto space-y-4 bg-black">
            </div>
        <div class="p-4 border-t border-[#27272a] bg-black/80">
            <form id="chat-form" class="flex items-center gap-2">
                <input type="text" id="chat-input" class="w-full p-3 bg-black border border-[#27272a] rounded-md focus:ring-1 focus:ring-white outline-none text-sm" placeholder="Ask about the insights...">
                <button type="submit" class="btn-primary p-3 rounded-md shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z" clip-rule="evenodd" /></svg>
                </button>
            </form>
        </div>
    </div>

    <script type="module">
        // Note: Three.js import is no longer needed
        // import * as THREE from 'three';

        document.addEventListener('DOMContentLoaded', () => {

            // --- Background 3D DNA Model (Three.js) ---
            // This entire section has been commented out as it is replaced by the Spline model
            /*
            const bgCanvas = document.getElementById('bg-dna-canvas');
            if (bgCanvas) {
                const scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x000000, 10, 40);
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ canvas: bgCanvas, alpha: true, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
               
                const ambientLight = new THREE.AmbientLight(0x40a0ff, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0x80c0ff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);
               
                const group = new THREE.Group();
                group.rotation.x = Math.PI / 8;
                group.rotation.y = -Math.PI / 4;
               
                const helixRadius = 3;
                const helixHeight = 40;
                const turnCount = 10;
                const basePairs = 150;
                const baseColors = [0x00aaff, 0x0088cc, 0x006699];

                const createStrand = () => {
                    const curve = new THREE.CatmullRomCurve3(
                        Array.from({ length: 200 }, (_, i) => {
                            const t = (i / 199) * helixHeight;
                            return new THREE.Vector3(
                                helixRadius * Math.cos(t * turnCount * Math.PI / helixHeight),
                                t - helixHeight / 2,
                                helixRadius * Math.sin(t * turnCount * Math.PI / helixHeight)
                            );
                        })
                    );
                    const geometry = new THREE.TubeGeometry(curve, 100, 0.15, 12, false);
                    const material = new THREE.MeshPhongMaterial({ color: 0x0055aa, shininess: 30 });
                    return new THREE.Mesh(geometry, material);
                };

                const strand1 = createStrand();
                const strand2 = createStrand();
                strand2.rotation.y = Math.PI;
                group.add(strand1, strand2);

                for (let i = 0; i < basePairs; i++) {
                    const t = (i / (basePairs - 1)) * helixHeight;
                    const y = t - helixHeight / 2;
                    const angle = t * turnCount * Math.PI / helixHeight;
                    const start = new THREE.Vector3(helixRadius * Math.cos(angle), y, helixRadius * Math.sin(angle));
                    const end = new THREE.Vector3(helixRadius * Math.cos(angle + Math.PI), y, helixRadius * Math.sin(angle + Math.PI));
                    const distance = start.distanceTo(end);
                    const position = start.clone().add(end).divideScalar(2);
                    const cylinderGeometry = new THREE.CylinderGeometry(0.08, 0.08, distance, 8);
                    const cylinderMaterial = new THREE.MeshPhongMaterial({
                        color: baseColors[i % baseColors.length],
                        emissive: baseColors[i % baseColors.length],
                        emissiveIntensity: 0.3
                    });
                    const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                    cylinder.position.copy(position);
                    cylinder.lookAt(end);
                    cylinder.rotateX(Math.PI / 2);
                    group.add(cylinder);
                }
                scene.add(group);

                const initialCameraZ = 40;
                const finalCameraZ = 5;
                camera.position.z = initialCameraZ;

                const animate = () => {
                    requestAnimationFrame(animate);
                    group.rotation.y += 0.0005;
                    renderer.render(scene, camera);
                };
                animate();

                function handleScrollAnimation() {
                    const scrollY = window.scrollY;
                    const animationScrollHeight = window.innerHeight;
                    const scrollFraction = Math.min(scrollY / animationScrollHeight, 1);
                    const easedFraction = 1 - Math.pow(1 - scrollFraction, 3);
                    camera.position.z = THREE.MathUtils.lerp(initialCameraZ, finalCameraZ, easedFraction);
                    camera.position.y = THREE.MathUtils.lerp(0, helixHeight / 4, easedFraction);
                    group.rotation.y = THREE.MathUtils.lerp(-Math.PI / 4, Math.PI, easedFraction);
                    group.rotation.x = THREE.MathUtils.lerp(Math.PI / 8, -Math.PI / 16, easedFraction);
                }
                window.addEventListener('scroll', handleScrollAnimation, { passive: true });
               
                window.addEventListener('resize', () => {
                    const newWidth = window.innerWidth;
                    const newHeight = window.innerHeight;
                    camera.aspect = newWidth / newHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(newWidth, newHeight);
                });
            }
            */

            // --- Text Scramble Effect ---
            class TextScrambleEffect {
                constructor(el) { this.el = el; this.chars = '!<>-_\\/[]{}‚Äî=+*^?#________'; this.update = this.update.bind(this); }
                setText(newText) {
                    const oldText = this.el.innerText;
                    const length = Math.max(oldText.length, newText.length);
                    const promise = new Promise((resolve) => this.resolve = resolve);
                    this.queue = [];
                    for (let i = 0; i < length; i++) {
                        const from = oldText[i] || ''; const to = newText[i] || '';
                        const start = Math.floor(Math.random() * 40); const end = start + Math.floor(Math.random() * 40);
                        this.queue.push({ from, to, start, end });
                    }
                    cancelAnimationFrame(this.frameRequest); this.frame = 0; this.update(); return promise;
                }
                update() {
                    let output = ''; let complete = 0;
                    for (let i = 0, n = this.queue.length; i < n; i++) {
                        let { from, to, start, end, char } = this.queue[i];
                        if (this.frame >= end) { complete++; output += to; } 
                        else if (this.frame >= start) {
                            if (!char || Math.random() < 0.28) { char = this.randomChar(); this.queue[i].char = char; }
                            output += `<span class="opacity-50">${char}</span>`;
                        } else { output += from; }
                    }
                    this.el.innerHTML = output;
                    if (complete === this.queue.length) { this.resolve(); } 
                    else { this.frameRequest = requestAnimationFrame(this.update); this.frame++; }
                }
                randomChar() { return this.chars[Math.floor(Math.random() * this.chars.length)]; }
            }
           
            const scrambleElements = document.querySelectorAll('.text-scramble');
            scrambleElements.forEach(el => {
                const fx = new TextScrambleEffect(el); const originalText = el.dataset.text;
                setTimeout(() => {
                    el.nextElementSibling.style.display = 'inline-block';
                    fx.setText(originalText).then(() => { setTimeout(() => { el.nextElementSibling.style.display = 'none'; }, 1000); });
                }, 500);
            });

            // --- Scroll Reveal Effect ---
            const revealElements = document.querySelectorAll('[data-reveal]');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) { entry.target.classList.add('visible'); observer.unobserve(entry.target); }
                });
            }, { threshold: 0.1 });
            revealElements.forEach(el => { observer.observe(el); });

            // --- Page Navigation and UI Logic ---
            const homePage = document.getElementById('homePage');
            const loginPage = document.getElementById('loginPage');
            const dashboardPage = document.getElementById('dashboardPage');
            const loginBtn = document.getElementById('loginBtn');
            const loginForm = document.getElementById('loginForm');
            const logoutBtn = document.getElementById('logoutBtn');
            const userToggle = document.getElementById('userToggle');
            const adminToggle = document.getElementById('adminToggle');
            const splineViewer = document.querySelector('spline-viewer');

            loginBtn.addEventListener('click', () => { 
                homePage.style.display = 'none'; 
                loginPage.style.display = 'flex'; 
                if (splineViewer) splineViewer.style.display = 'none'; // Hide 3D model for performance
            });
            
            // Disclaimer modal elements
            const disclaimerModal = document.getElementById('disclaimerModal');
            const closeDisclaimerBtn = document.getElementById('closeDisclaimerBtn');
            
            loginForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const email = document.getElementById('email').value;
                const isAdminActive = adminToggle.classList.contains('bg-white');

                if (isAdminActive) {
                    window.location.href = './admin.html'; 
                } else {
                    loginPage.style.display = 'none';
                    // Show disclaimer modal first
                    disclaimerModal.classList.remove('hidden');
                    if (splineViewer) splineViewer.style.display = 'none'; // Keep 3D model hidden on dashboard
                }
            });
            
            // Close disclaimer and show dashboard
            closeDisclaimerBtn.addEventListener('click', () => {
                disclaimerModal.classList.add('hidden');
                dashboardPage.style.display = 'block';
            });
            
            logoutBtn.addEventListener('click', () => {
                dashboardPage.style.display = 'none';
                homePage.style.display = 'block';
                if (splineViewer) splineViewer.style.display = 'block'; // Show 3D model again on home page
                document.getElementById('resultsSection').classList.add('hidden');
                document.getElementById('dnaSequenceInput').value = '';
                // Hide chat elements on logout
                chatBtn.classList.add('hidden');
                chatbotContainer.classList.add('hidden');
                chatMessages.innerHTML = '';
            });
            const setToggle = (active, inactive) => {
                 active.classList.add('bg-white', 'text-black'); 
                 active.classList.remove('text-gray-400');
                 inactive.classList.remove('bg-white', 'text-black'); 
                 inactive.classList.add('text-gray-400');
            };
            userToggle.addEventListener('click', () => setToggle(userToggle, adminToggle));
            adminToggle.addEventListener('click', () => setToggle(adminToggle, userToggle));

            // ===============================================================
            // ================== API INTEGRATION STARTS HERE ================
            // ===============================================================
            const analyzeBtn = document.getElementById('analyzeBtn');
            const batchAnalyzeBtn = document.getElementById('batchAnalyzeBtn');
            const csvFileInput = document.getElementById('csvFileInput');
            const csvUploadBtn = document.getElementById('csvUploadBtn');
           
            const resultsSection = document.getElementById('resultsSection');
            const pipelineStatusEl = document.getElementById('pipelineStatus');
            const markerResultsCard = document.getElementById('markerResultsCard');
            const markerResultsContent = document.getElementById('markerResultsContent');
            const classificationResultEl = document.getElementById('classificationResult');
            const noveltyResultEl = document.getElementById('noveltyResult');
            const insightsResultEl = document.getElementById('insightsResult');
            const analyzeButtonText = 'INITIATE ANALYSIS';
            const generateReportBtn = document.getElementById('generateReportBtn');
            const reportModal = document.getElementById('reportModal');
            const closeModalBtn = document.getElementById('closeModalBtn');
            const downloadSummaryReportBtn = document.getElementById('downloadSummaryReportBtn');
            const downloadDetailedReportBtn = document.getElementById('downloadDetailedReportBtn');
            const modalLoader = document.getElementById('modal-loader');
            const modalButtons = document.getElementById('modal-buttons');

            // --- Chatbot elements ---
            const chatBtn = document.getElementById('chatBtn');
            const chatbotContainer = document.getElementById('chatbot-container');
            const closeChatbotBtn = document.getElementById('closeChatbotBtn');
            const chatForm = document.getElementById('chat-form');
            const chatInput = document.getElementById('chat-input');
            const chatMessages = document.getElementById('chat-messages');
           
            // ===============================================================
            // =============== MOCK DATA GENERATION SYSTEM ==================
            // ===============================================================
            // This website uses mock data for demonstration purposes.
            // No external APIs are called - all results are generated locally.
            
            const MOCK_MODE = true; // All APIs are replaced with mock functions
            
            // Mock species database for generating fake classifications
            const MOCK_SPECIES_DATABASE = [
                { kingdom: 'Eukaryota', phylum: 'Chordata', class: 'Actinopterygii', order: 'Perciformes', family: 'Serranidae', genus: 'Epinephelus', species: 'Epinephelus malabaricus', common: 'Malabar Grouper' },
                { kingdom: 'Eukaryota', phylum: 'Arthropoda', class: 'Malacostraca', order: 'Decapoda', family: 'Penaeidae', genus: 'Penaeus', species: 'Penaeus monodon', common: 'Giant Tiger Prawn' },
                { kingdom: 'Eukaryota', phylum: 'Mollusca', class: 'Cephalopoda', order: 'Octopoda', family: 'Octopodidae', genus: 'Octopus', species: 'Octopus vulgaris', common: 'Common Octopus' },
                { kingdom: 'Eukaryota', phylum: 'Cnidaria', class: 'Anthozoa', order: 'Scleractinia', family: 'Acroporidae', genus: 'Acropora', species: 'Acropora cervicornis', common: 'Staghorn Coral' },
                { kingdom: 'Eukaryota', phylum: 'Annelida', class: 'Polychaeta', order: 'Phyllodocida', family: 'Nereididae', genus: 'Nereis', species: 'Nereis virens', common: 'Sandworm' },
                { kingdom: 'Eukaryota', phylum: 'Echinodermata', class: 'Asteroidea', order: 'Forcipulatida', family: 'Asteriidae', genus: 'Asterias', species: 'Asterias rubens', common: 'Common Starfish' },
                { kingdom: 'Eukaryota', phylum: 'Porifera', class: 'Demospongiae', order: 'Haplosclerida', family: 'Chalinidae', genus: 'Haliclona', species: 'Haliclona oculata', common: 'Eyed Sponge' },
                { kingdom: 'Eukaryota', phylum: 'Chordata', class: 'Chondrichthyes', order: 'Carcharhiniformes', family: 'Carcharhinidae', genus: 'Carcharhinus', species: 'Carcharhinus melanopterus', common: 'Blacktip Reef Shark' },
                { kingdom: 'Eukaryota', phylum: 'Mollusca', class: 'Bivalvia', order: 'Ostreoida', family: 'Ostreidae', genus: 'Crassostrea', species: 'Crassostrea gigas', common: 'Pacific Oyster' },
                { kingdom: 'Eukaryota', phylum: 'Arthropoda', class: 'Maxillopoda', order: 'Calanoida', family: 'Calanidae', genus: 'Calanus', species: 'Calanus finmarchicus', common: 'Copepod' },
                { kingdom: 'Eukaryota', phylum: 'Cnidaria', class: 'Hydrozoa', order: 'Siphonophorae', family: 'Physaliidae', genus: 'Physalia', species: 'Physalia physalis', common: 'Portuguese Man o War' },
                { kingdom: 'Eukaryota', phylum: 'Chordata', class: 'Mammalia', order: 'Cetacea', family: 'Delphinidae', genus: 'Tursiops', species: 'Tursiops truncatus', common: 'Bottlenose Dolphin' },
                { kingdom: 'Eukaryota', phylum: 'Chordata', class: 'Reptilia', order: 'Testudines', family: 'Cheloniidae', genus: 'Chelonia', species: 'Chelonia mydas', common: 'Green Sea Turtle' },
                { kingdom: 'Eukaryota', phylum: 'Ctenophora', class: 'Tentaculata', order: 'Lobata', family: 'Mnemiidae', genus: 'Mnemiopsis', species: 'Mnemiopsis leidyi', common: 'Sea Walnut' },
                { kingdom: 'Eukaryota', phylum: 'Arthropoda', class: 'Merostomata', order: 'Xiphosura', family: 'Limulidae', genus: 'Limulus', species: 'Limulus polyphemus', common: 'Horseshoe Crab' }
            ];
            
            // Mock novel species that don't exist in databases
            const MOCK_NOVEL_SPECIES = [
                { kingdom: 'Eukaryota', phylum: 'Arthropoda', class: 'Malacostraca', order: 'Decapoda', family: 'Unknown', genus: 'Novacaris', species: 'Novacaris abyssalis' },
                { kingdom: 'Eukaryota', phylum: 'Annelida', class: 'Polychaeta', order: 'Unknown', family: 'Unknown', genus: 'Cryptoworm', species: 'Cryptoworm thermophilus' },
                { kingdom: 'Eukaryota', phylum: 'Cnidaria', class: 'Anthozoa', order: 'Actiniaria', family: 'Unknown', genus: 'Abyssanemone', species: 'Abyssanemone gigantea' }
            ];
            
            // Generate a unique identifier for novel species
            function generateMockUID() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let uid = 'BLC-';
                for (let i = 0; i < 8; i++) {
                    uid += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return uid;
            }
            
            // Mock gene marker detection
            async function mockGeneMarkerApi(sequence) {
                // Simulate API delay
                await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 400));
                
                const markerTypes = ['COI', '18S rRNA'];
                const selectedMarker = markerTypes[Math.floor(Math.random() * markerTypes.length)];
                
                // Generate mock prediction
                const startPos = Math.floor(Math.random() * Math.max(1, sequence.length - 200));
                const markerSequence = sequence.substring(startPos, Math.min(startPos + 180, sequence.length));
                
                return {
                    predictions: [{
                        label: selectedMarker,
                        sequence: markerSequence,
                        confidence: 0.85 + Math.random() * 0.14,
                        start: startPos,
                        end: startPos + markerSequence.length
                    }]
                };
            }
            
            // Mock DNABERT classification
            async function mockDnabertApi(sequence, markerType = 'Unknown') {
                // Simulate API delay
                await new Promise(resolve => setTimeout(resolve, 400 + Math.random() * 600));
                
                // 20% chance of being a novel species
                const isNovel = Math.random() < 0.20;
                
                let classification;
                if (isNovel) {
                    classification = MOCK_NOVEL_SPECIES[Math.floor(Math.random() * MOCK_NOVEL_SPECIES.length)];
                } else {
                    classification = MOCK_SPECIES_DATABASE[Math.floor(Math.random() * MOCK_SPECIES_DATABASE.length)];
                }
                
                const uid = isNovel ? generateMockUID() : null;
                
                return {
                    classification: {
                        Kingdom: classification.kingdom,
                        Phylum: classification.phylum,
                        Class: classification.class,
                        Order: classification.order,
                        Family: classification.family,
                        Genus: classification.genus,
                        Species: classification.species
                    },
                    is_novel: isNovel,
                    uid: uid,
                    message: isNovel ? 'Novel species detected - not found in reference databases' : 'Species classified successfully',
                    // Backwards compatible fields
                    predicted_taxa: classification.species,
                    predicted_level: 'Species',
                    predicted_group: classification.kingdom,
                    taxa_confidence: isNovel ? 0.6 + Math.random() * 0.2 : 0.85 + Math.random() * 0.14,
                    group_confidence: 0.9 + Math.random() * 0.09,
                    novelty_status: isNovel ? `Novel Species - UID: ${uid}` : 'Known Species',
                    kingdom: classification.kingdom,
                    phylum: classification.phylum,
                    class: classification.class,
                    order: classification.order,
                    family: classification.family,
                    genus: classification.genus,
                    species: classification.species
                };
            }
            
            // Mock ecological insights generation
            async function mockGenerateInsights(results) {
                // Simulate API delay
                await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 1000));
                
                const numSpecies = new Set(results.map(r => r.species)).size;
                const numNovel = results.filter(r => r.is_novel).length;
                
                // Group by phylum
                const phylumCounts = results.reduce((acc, r) => {
                    const p = r.phylum || 'Unknown';
                    acc[p] = (acc[p] || 0) + 1;
                    return acc;
                }, {});
                
                const dominantPhylum = Object.entries(phylumCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || 'Unknown';
                
                return {
                    summary: {
                        title: 'Ecological Summary',
                        insight: `This eDNA analysis identified ${results.length} sequences representing ${numSpecies} unique taxa across multiple marine phyla. The community shows ${numNovel > 0 ? 'notable biodiversity with ' + numNovel + ' potentially novel species detected' : 'typical composition for the sampled environment'}. The presence of diverse taxonomic groups indicates a functioning ecosystem with multiple trophic levels represented.`
                    },
                    biodiversity_assessment: {
                        title: 'Biodiversity Assessment',
                        insight: `The sample demonstrates ${numSpecies > 10 ? 'high' : numSpecies > 5 ? 'moderate' : 'low'} species richness with ${numSpecies} identified taxa. Species evenness appears ${Math.random() > 0.5 ? 'relatively balanced' : 'dominated by a few abundant taxa'}, suggesting ${Math.random() > 0.5 ? 'a stable community structure' : 'possible environmental pressures affecting community dynamics'}.`,
                        richness_value: numSpecies,
                        evenness_category: numSpecies > 8 ? 'High' : numSpecies > 4 ? 'Moderate' : 'Low'
                    },
                    community_structure: {
                        title: 'Community Structure',
                        insight: `The community is dominated by ${dominantPhylum}, which comprises ${((phylumCounts[dominantPhylum] / results.length) * 100).toFixed(1)}% of identified sequences. This taxonomic composition is consistent with ${Math.random() > 0.5 ? 'a healthy benthic community' : 'deep-sea environmental conditions'}. The presence of multiple phyla indicates ecological complexity.`,
                        major_groups: phylumCounts
                    },
                    dominant_taxa: {
                        title: 'Dominant Taxa & Significance',
                        insight: `The most abundant taxa belong to ${dominantPhylum}, which play crucial roles in marine ecosystems. These organisms typically serve as ${dominantPhylum === 'Arthropoda' ? 'important links in the food web, serving as both predators and prey' : dominantPhylum === 'Chordata' ? 'apex or meso-predators regulating lower trophic levels' : 'foundation species providing habitat structure'}. Their presence indicates ${Math.random() > 0.5 ? 'productive ecosystem conditions' : 'stable environmental parameters'}.`
                    },
                    trophic_levels: {
                        title: 'Ecological Roles & Food Web',
                        insight: `The identified taxa span multiple trophic levels, from ${phylumCounts['Porifera'] ? 'filter feeders (sponges)' : 'primary consumers'} to ${phylumCounts['Chordata'] ? 'apex predators (fish, mammals)' : 'secondary consumers'}. This trophic diversity suggests a complex food web with energy flow through multiple pathways. The presence of detritivores and filter feeders indicates active nutrient cycling.`
                    },
                    bioindicators: {
                        title: 'Bioindicator Analysis',
                        insight: `Several identified taxa serve as bioindicators for environmental conditions. ${phylumCounts['Cnidaria'] ? 'Cnidarians (corals) indicate water quality and temperature stability. ' : ''}${phylumCounts['Echinodermata'] ? 'Echinoderms suggest good oxygen levels and sediment quality. ' : ''}${numNovel > 0 ? 'The detection of potentially novel species highlights the importance of this habitat for undiscovered biodiversity and warrants further investigation.' : 'The absence of pollution-indicator species suggests relatively healthy environmental conditions.'}`
                    }
                };
            }
            
            // Mock chatbot response
            async function mockChatbotResponse(question, insightsData) {
                await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 700));
                
                const questionLower = question.toLowerCase();
                
                if (questionLower.includes('novel') || questionLower.includes('new species')) {
                    return "Based on this analysis, several sequences were flagged as potentially **novel species** not found in current reference databases. These specimens warrant further investigation through morphological examination and additional molecular markers. Novel species detection is an exciting aspect of eDNA analysis!";
                }
                if (questionLower.includes('biodiversity') || questionLower.includes('diversity')) {
                    return `The biodiversity assessment shows **${insightsData?.biodiversity_assessment?.evenness_category || 'moderate'} evenness** with ${insightsData?.biodiversity_assessment?.richness_value || 'multiple'} taxa identified. Higher diversity typically indicates a more resilient ecosystem capable of withstanding environmental perturbations.`;
                }
                if (questionLower.includes('dominant') || questionLower.includes('abundant')) {
                    return "The dominant taxa in this sample play crucial ecological roles. Their abundance reflects their adaptation to local conditions and their position in the food web. Monitoring dominant species over time helps track ecosystem health.";
                }
                if (questionLower.includes('threat') || questionLower.includes('conservation')) {
                    return "Based on the community composition, key conservation considerations include: **1)** Protecting habitat complexity for diverse species, **2)** Monitoring water quality parameters, **3)** Establishing baseline data for detecting future changes, and **4)** Further investigating potentially novel species.";
                }
                if (questionLower.includes('food web') || questionLower.includes('trophic')) {
                    return "The identified taxa span multiple **trophic levels**, from filter feeders and detritivores at the base to predatory species higher up. This complexity indicates a healthy ecosystem with efficient energy transfer between levels.";
                }
                
                return `Great question! Based on the ecological analysis, I can tell you that this sample shows interesting patterns of marine biodiversity. The community composition includes representatives from multiple phyla, indicating ecological complexity. Would you like to know more about any specific aspect - perhaps the **dominant species**, **diversity metrics**, or **conservation implications**?`;
            }
            
            // ===============================================================
            // ============= END MOCK DATA GENERATION SYSTEM ================
            // ===============================================================
            
            let parsedCsvData = [];
            let currentInsightsData = null; 
            let detailedReportData = [];
            let clusteringData = null;  // Store clustering results
            let clusterScatterChart = null;  // Chart instance
            let currentPage = 1;  // Pagination state for results table
            const resultsPerPage = 5;  // Results per page
            let clusterPage = 1;  // Pagination for cluster details
            const clustersPerPage = 3;  // Clusters per page
            let heatmapInstance = null;  // Store Leaflet map instance
            let locationData = [];  // Store location and taxonomic data

            // Define changeClusterPage globally so onclick handlers can access it
            window.changeClusterPage = function(page) {
                clusterPage = page;
                if (window.clusteringData && window.clusteringData.clusters) {
                    displayClusterDetails(window.clusteringData.clusters, window.clusteringData.results);
                }
            };

            // ===============================================================
            // ============== GEOGRAPHIC HEATMAP FUNCTIONALITY ===============
            // ===============================================================
            
            function initializeHeatmap() {
                const container = document.getElementById('heatmapContainer');
                if (!container) return;
                
                // Clear any existing map
                if (heatmapInstance) {
                    heatmapInstance.remove();
                    heatmapInstance = null;
                }
                
                // Create Leaflet map centered on Bay of Bengal (default)
                heatmapInstance = L.map('heatmapContainer', {
                    zoomControl: false, // We'll add custom zoom control
                    minZoom: 3,
                    maxZoom: 18,
                    scrollWheelZoom: true,
                    doubleClickZoom: true,
                    boxZoom: true,
                    keyboard: true,
                    dragging: true,
                    touchZoom: true
                }).setView([20.5937, 88.2636], 5);
                
                // Add custom zoom control on the right side
                L.control.zoom({
                    position: 'topright'
                }).addTo(heatmapInstance);
                
                // Add scale control
                L.control.scale({
                    position: 'bottomleft',
                    metric: true,
                    imperial: false,
                    maxWidth: 150
                }).addTo(heatmapInstance);
                
                // Use CartoDB Positron (light with labels) as base for geographic context
                const baseLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                    subdomains: 'abcd',
                    maxZoom: 18,
                    minZoom: 3
                }).addTo(heatmapInstance);
                
                // Add dark overlay on top to create dark theme while keeping labels visible
                const darkOverlay = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
                    attribution: '',
                    subdomains: 'abcd',
                    maxZoom: 18,
                    minZoom: 3,
                    opacity: 0.7
                }).addTo(heatmapInstance);
                
                // Add labels layer on top so they're visible
                const labelsLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', {
                    attribution: '',
                    subdomains: 'abcd',
                    maxZoom: 18,
                    minZoom: 3,
                    opacity: 0.8
                }).addTo(heatmapInstance);
                
                return heatmapInstance;
            }
            
            function generateHeatmapData(results, latitude, longitude) {
                if (!latitude || !longitude || !results || results.length === 0) {
                    return [];
                }
                
                const lat = parseFloat(latitude);
                const lon = parseFloat(longitude);
                
                if (isNaN(lat) || isNaN(lon)) {
                    return [];
                }
                
                // Group results by phylum to create realistic biodiversity clusters
                const phylumGroups = {};
                results.forEach(result => {
                    const phylum = result.phylum || 'Unknown';
                    if (!phylumGroups[phylum]) {
                        phylumGroups[phylum] = [];
                    }
                    phylumGroups[phylum].push(result);
                });
                
                const heatmapPoints = [];
                const phylumCount = Object.keys(phylumGroups).length;
                
                // Create distinct clusters for each phylum
                Object.entries(phylumGroups).forEach(([phylum, groupResults], phylumIndex) => {
                    // Create a cluster center for this phylum (distributed around main location)
                    const angle = (phylumIndex / phylumCount) * 2 * Math.PI;
                    const clusterDistance = 0.15 + Math.random() * 0.25; // 15-40km radius clusters (more spread out)
                    const clusterCenterLat = lat + Math.cos(angle) * clusterDistance;
                    const clusterCenterLon = lon + Math.sin(angle) * clusterDistance;
                    
                    // Add samples within this cluster
                    groupResults.forEach((result, index) => {
                        // Calculate intensity based on taxonomic classification depth and specificity
                        let intensity = 0.4; // Base intensity
                        
                        // Higher intensity for more specific classifications
                        if (result.species && result.species !== 'Unknown' && result.species !== 'N/A') {
                            intensity = 0.9;
                        } else if (result.genus && result.genus !== 'Unknown' && result.genus !== 'N/A') {
                            intensity = 0.75;
                        } else if (result.family && result.family !== 'Unknown' && result.family !== 'N/A') {
                            intensity = 0.6;
                        } else if (result.order && result.order !== 'Unknown' && result.order !== 'N/A') {
                            intensity = 0.5;
                        }
                        
                        // Novel species get significantly higher intensity (red zones)
                        if (result.is_novel) {
                            intensity = 1.0;
                        }
                        
                        // Use normal distribution for realistic clustering (slightly larger spread)
                        const stdDev = 0.03; // ~3km standard deviation
                        const offsetLat = clusterCenterLat + (Math.random() + Math.random() - 1) * stdDev;
                        const offsetLon = clusterCenterLon + (Math.random() + Math.random() - 1) * stdDev;
                        
                        // Add multiple points for higher intensity samples to increase heat density
                        const pointCount = Math.ceil(intensity * 3);
                        for (let i = 0; i < pointCount; i++) {
                            const microOffsetLat = offsetLat + (Math.random() - 0.5) * 0.005;
                            const microOffsetLon = offsetLon + (Math.random() - 0.5) * 0.005;
                            heatmapPoints.push([microOffsetLat, microOffsetLon, intensity]);
                        }
                        
                        // Store for marker display (only once per sample)
                        if (index === 0 || Math.random() > 0.7) { // Show some representative markers
                            locationData.push({
                                lat: offsetLat,
                                lon: offsetLon,
                                taxa: result.predicted_taxa || result.species || result.genus || result.family || 'Unknown',
                                kingdom: result.kingdom || 'Unknown',
                                phylum: phylum,
                                class: result.class || 'Unknown',
                                family: result.family || 'Unknown',
                                isNovel: result.is_novel || false,
                                sampleId: result.original_sample_id || `sample_${index + 1}`,
                                intensity: intensity
                            });
                        }
                    });
                });
                
                return heatmapPoints;
            }
            
            function displayGeographicHeatmap(results, latitude, longitude) {
                const heatmapCard = document.getElementById('heatmapCard');
                if (!heatmapCard) return;
                
                // Show the card
                heatmapCard.classList.remove('hidden');
                
                // Initialize map
                const map = initializeHeatmap();
                if (!map) return;
                
                // Generate heatmap data
                const heatmapData = generateHeatmapData(results, latitude, longitude);
                
                if (heatmapData.length === 0) {
                    document.getElementById('heatmapContainer').innerHTML = 
                        '<div class=\"flex items-center justify-center h-full text-gray-500\">No geographic data available. Please provide latitude and longitude.</div>';
                    return;
                }
                
                // Create heat layer with enhanced gradient and settings
                const heatLayer = L.heatLayer(heatmapData, {
                    radius: 25,
                    blur: 15,
                    maxZoom: 17,
                    max: 1.0,
                    minOpacity: 0.4,
                    gradient: {
                        0.0: '#0000ff',  // Blue - lowest density
                        0.2: '#00ffff',  // Cyan
                        0.4: '#00ff00',  // Green - low-medium density
                        0.6: '#ffff00',  // Yellow - medium-high density
                        0.8: '#ff8000',  // Orange - high density
                        1.0: '#ff0000'   // Red - highest density (novel species)
                    }
                }).addTo(map);
                
                // Create marker cluster group for better performance
                const markerGroup = L.featureGroup();
                
                // Add enhanced markers with size based on intensity
                locationData.forEach(loc => {
                    const markerSize = loc.isNovel ? 14 : (10 + loc.intensity * 4);
                    const markerColor = loc.isNovel ? '#fbbf24' : (loc.intensity > 0.7 ? '#ef4444' : loc.intensity > 0.5 ? '#f59e0b' : '#3b82f6');
                    const pulseAnimation = loc.isNovel ? 'animation: pulse 2s infinite;' : '';
                    
                    const markerIcon = L.divIcon({
                        className: 'custom-marker',
                        html: `
                            <style>
                                @keyframes pulse {
                                    0%, 100% { transform: scale(1); opacity: 1; }
                                    50% { transform: scale(1.3); opacity: 0.7; }
                                }
                            </style>
                            <div style="
                                background: radial-gradient(circle, ${markerColor} 0%, ${markerColor}dd 50%, ${markerColor}88 100%);
                                width: ${markerSize}px;
                                height: ${markerSize}px;
                                border-radius: 50%;
                                border: 2px solid white;
                                box-shadow: 0 0 10px ${markerColor}88, 0 0 20px ${markerColor}44;
                                ${pulseAnimation}
                            "></div>
                        `,
                        iconSize: [markerSize, markerSize]
                    });
                    
                    const marker = L.marker([loc.lat, loc.lon], { icon: markerIcon });
                    
                    // Enhanced popup with more taxonomic details
                    const intensityBar = `<div style="width: 100%; height: 6px; background: linear-gradient(to right, #0000ff, #00ff00, #ffff00, #ff0000); border-radius: 3px; margin: 5px 0;"><div style="width: ${loc.intensity * 100}%; height: 100%; background: rgba(0,0,0,0.3); border-radius: 3px;"></div></div>`;
                    
                    const popupContent = `
                        <div style="font-family: 'Inter', sans-serif; font-size: 11px; color: #000; min-width: 200px;">
                            <div style="font-weight: bold; margin-bottom: 8px; padding: 5px; border-radius: 4px; text-align: center; background: ${loc.isNovel ? '#fef3c7' : '#dbeafe'}; color: ${loc.isNovel ? '#92400e' : '#1e3a8a'};">
                                ${loc.isNovel ? 'üÜï NOVEL SPECIES' : '‚úì KNOWN SPECIES'}
                            </div>
                            <div style="margin-bottom: 3px;"><strong>Sample ID:</strong> ${loc.sampleId}</div>
                            <div style="margin-bottom: 3px;"><strong>Taxa:</strong> <em>${loc.taxa}</em></div>
                            <div style="margin-bottom: 8px; padding: 5px; background: #f3f4f6; border-radius: 3px; font-size: 10px;">
                                <div><strong>Kingdom:</strong> ${loc.kingdom}</div>
                                <div><strong>Phylum:</strong> ${loc.phylum}</div>
                                ${loc.class !== 'Unknown' ? `<div><strong>Class:</strong> ${loc.class}</div>` : ''}
                                ${loc.family !== 'Unknown' ? `<div><strong>Family:</strong> ${loc.family}</div>` : ''}
                            </div>
                            <div style="margin-bottom: 3px; font-size: 10px;"><strong>Heat Intensity:</strong></div>
                            ${intensityBar}
                            <div style="margin-top: 8px; padding-top: 5px; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 10px;">
                                <strong>üìç Coordinates:</strong> ${loc.lat.toFixed(5)}¬∞N, ${loc.lon.toFixed(5)}¬∞E
                            </div>
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent, {
                        maxWidth: 300,
                        className: 'custom-popup'
                    });
                    
                    // Add marker to group
                    markerGroup.addLayer(marker);
                });
                
                // Add all markers to map
                markerGroup.addTo(map);
                
                // Calculate bounds from all points and fit map to show all data
                const lat = parseFloat(latitude);
                const lon = parseFloat(longitude);
                
                // Create bounds from location data
                if (locationData.length > 0) {
                    const lats = locationData.map(l => l.lat);
                    const lons = locationData.map(l => l.lon);
                    const minLat = Math.min(...lats);
                    const maxLat = Math.max(...lats);
                    const minLon = Math.min(...lons);
                    const maxLon = Math.max(...lons);
                    
                    // Add generous padding to the bounds to show geographic context
                    const latPadding = Math.max((maxLat - minLat) * 0.5, 0.5); // At least 0.5 degrees
                    const lonPadding = Math.max((maxLon - minLon) * 0.5, 0.5);
                    
                    const bounds = L.latLngBounds(
                        [minLat - latPadding, minLon - lonPadding],
                        [maxLat + latPadding, maxLon + lonPadding]
                    );
                    
                    // Fit map to bounds with animation - limit max zoom to see context
                    map.fitBounds(bounds, {
                        padding: [60, 60],
                        maxZoom: 10,  // Lower max zoom to show more geographic area
                        animate: true,
                        duration: 1
                    });
                } else {
                    // Fallback to center point with lower zoom
                    map.setView([lat, lon], 8);
                }
                
                // Add custom zoom buttons for quick access
                const zoomControlHTML = `
                    <div class="absolute top-4 left-4 z-[1000] flex flex-col gap-2" style="z-index: 1000;">
                        <button id="zoomToFit" class="bg-black/80 hover:bg-black text-white p-2 rounded-lg border border-gray-600 hover:border-white transition-all" title="Fit to All Points">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"/>
                            </svg>
                        </button>
                        <button id="zoomToCenter" class="bg-black/80 hover:bg-black text-white p-2 rounded-lg border border-gray-600 hover:border-white transition-all" title="Zoom to Sample Center">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/>
                            </svg>
                        </button>
                        <button id="zoomIn" class="bg-black/80 hover:bg-black text-white p-2 rounded-lg border border-gray-600 hover:border-white transition-all" title="Zoom In">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"/>
                            </svg>
                        </button>
                        <button id="zoomOut" class="bg-black/80 hover:bg-black text-white p-2 rounded-lg border border-gray-600 hover:border-white transition-all" title="Zoom Out">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7"/>
                            </svg>
                        </button>
                    </div>
                `;
                
                // Insert zoom controls
                const container = document.getElementById('heatmapContainer');
                const controlDiv = document.createElement('div');
                controlDiv.innerHTML = zoomControlHTML;
                controlDiv.style.position = 'absolute';
                controlDiv.style.top = '0';
                controlDiv.style.left = '0';
                controlDiv.style.zIndex = '1000';
                container.style.position = 'relative';
                container.appendChild(controlDiv.firstElementChild);
                
                // Store bounds for zoom to fit button
                const allBounds = locationData.length > 0 ? L.latLngBounds(locationData.map(l => [l.lat, l.lon])) : null;
                
                // Add event listeners for custom zoom buttons
                setTimeout(() => {
                    document.getElementById('zoomToFit')?.addEventListener('click', () => {
                        if (allBounds) {
                            map.fitBounds(allBounds.pad(0.2), { animate: true, duration: 0.5 });
                        }
                    });
                    
                    document.getElementById('zoomToCenter')?.addEventListener('click', () => {
                        map.setView([lat, lon], 11, { animate: true, duration: 0.5 });
                    });
                    
                    document.getElementById('zoomIn')?.addEventListener('click', () => {
                        map.zoomIn(1, { animate: true });
                    });
                    
                    document.getElementById('zoomOut')?.addEventListener('click', () => {
                        map.zoomOut(1, { animate: true });
                    });
                }, 100);
                
                // Update legend with statistics
                const knownCount = locationData.filter(l => !l.isNovel).length;
                const novelCount = locationData.filter(l => l.isNovel).length;
                const uniquePhyla = [...new Set(locationData.map(l => l.phylum))].filter(p => p !== 'Unknown').length;
                
                document.getElementById('heatmapLegend').innerHTML = `
                    <div class="text-xs text-gray-400 mb-3 font-semibold">HEATMAP STATISTICS</div>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div class="bg-black/50 p-3 rounded border border-[#3f3f46]">
                            <div class="text-white font-bold text-lg">${locationData.length}</div>
                            <div class="text-gray-400 text-xs">Sample Points</div>
                        </div>
                        <div class="bg-green-500/10 p-3 rounded border border-green-500/30">
                            <div class="text-green-400 font-bold text-lg">${knownCount}</div>
                            <div class="text-gray-400 text-xs">Known Species</div>
                        </div>
                        <div class="bg-yellow-500/10 p-3 rounded border border-yellow-500/30">
                            <div class="text-yellow-400 font-bold text-lg">${novelCount}</div>
                            <div class="text-gray-400 text-xs">Novel Species</div>
                        </div>
                        <div class="bg-blue-500/10 p-3 rounded border border-blue-500/30">
                            <div class="text-blue-400 font-bold text-lg">${uniquePhyla}</div>
                            <div class="text-gray-400 text-xs">Unique Phyla</div>
                        </div>
                    </div>
                    
                    <div class="pt-3 border-t border-[#27272a]">
                        <div class="text-xs text-gray-400 font-semibold mb-3">HEAT INTENSITY GRADIENT</div>
                        <div class="relative h-8 rounded-lg overflow-hidden mb-2" style="background: linear-gradient(to right, #0000ff 0%, #00ffff 15%, #00ff00 35%, #ffff00 60%, #ff8000 80%, #ff0000 100%);">
                            <div class="absolute inset-0 flex items-center justify-between px-2 text-[10px] font-bold text-white" style="text-shadow: 0 0 3px black, 0 0 5px black;">
                                <span>BLUE</span>
                                <span>CYAN</span>
                                <span>GREEN</span>
                                <span>YELLOW</span>
                                <span>ORANGE</span>
                                <span>RED</span>
                            </div>
                        </div>
                        <div class="flex justify-between text-[10px] text-gray-500 mb-4">
                            <span>Lowest</span>
                            <span>Low</span>
                            <span>Medium</span>
                            <span>High</span>
                            <span>Very High</span>
                            <span>Highest</span>
                        </div>
                    </div>
                    
                    <div class="pt-3 border-t border-[#27272a]">
                        <div class="text-xs text-gray-400 font-semibold mb-3">MARKER LEGEND</div>
                        <div class="grid grid-cols-2 gap-3">
                            <div class="flex items-center gap-2">
                                <div class="w-3 h-3 rounded-full" style="background: radial-gradient(circle, #3b82f6 0%, #3b82f688 100%); box-shadow: 0 0 8px #3b82f644;"></div>
                                <span class="text-xs text-gray-400">Low Intensity</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="w-3 h-3 rounded-full" style="background: radial-gradient(circle, #f59e0b 0%, #f59e0b88 100%); box-shadow: 0 0 8px #f59e0b44;"></div>
                                <span class="text-xs text-gray-400">Medium Intensity</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="w-4 h-4 rounded-full" style="background: radial-gradient(circle, #ef4444 0%, #ef444488 100%); box-shadow: 0 0 10px #ef444444;"></div>
                                <span class="text-xs text-gray-400">High Intensity</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="w-4 h-4 rounded-full animate-pulse" style="background: radial-gradient(circle, #fbbf24 0%, #fbbf2488 100%); box-shadow: 0 0 12px #fbbf2466;"></div>
                                <span class="text-xs text-yellow-400 font-semibold">Novel Species</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mt-3 pt-3 border-t border-[#27272a] text-[10px] text-gray-500">
                        <strong>üí° Tips:</strong>
                        <ul class="mt-1 space-y-1 list-disc list-inside">
                            <li>Use <kbd class="px-1 py-0.5 bg-gray-800 rounded text-gray-300">scroll wheel</kbd> to zoom in/out</li>
                            <li>Use buttons on the left for quick navigation</li>
                            <li><kbd class="px-1 py-0.5 bg-gray-800 rounded text-gray-300">Click + drag</kbd> to pan the map</li>
                            <li><kbd class="px-1 py-0.5 bg-gray-800 rounded text-gray-300">Double-click</kbd> to zoom to a specific area</li>
                            <li>Click markers to view detailed taxonomic info</li>
                        </ul>
                    </div>
                `;
            }
            
            // ===============================================================
            // ============ END GEOGRAPHIC HEATMAP FUNCTIONALITY =============
            // ===============================================================

            analyzeBtn.addEventListener('click', async () => {
                const dnaInput = document.getElementById('dnaSequenceInput');
                let rawSequence = dnaInput.value.trim();
                if (rawSequence === "") {
                    rawSequence = "> Using example sequence...\nGATCCTCCAGENTTAGTTCGCTTGCACTGAATAGACCCGTCACACAGGAGAGTTTCTACAGGCGGTTAGAATAAAATCAATAGGACTCTTTCGAGGCCCTGTAATTGGAATGAGTCCACGTTAATAAGGGTGAGGGTCGGCTGTTCCTAGGGCCGAGGTCGTGAGTGGTGGTTATGCCTGTCGAACTAGAGATCGGTGAGAGGGGATTCGTATT";
                    dnaInput.value = rawSequence;
                }
                await performSingleAnalysis(rawSequence);
            });

            csvUploadBtn.addEventListener('click', () => csvFileInput.click());

            // Parse FASTA file format
            function parseFasta(content) {
                const sequences = [];
                const lines = content.split('\n').filter(line => line.trim() !== '');
                let currentId = null;
                let currentSeq = '';
                
                for (const line of lines) {
                    if (line.startsWith('>')) {
                        // Save previous sequence if exists
                        if (currentId) {
                            sequences.push({
                                sample_id: currentId,
                                sequence: currentSeq
                            });
                        }
                        // Start new sequence
                        currentId = line.substring(1).trim().split(/\s+/)[0]; // Get ID (first word after >)
                        currentSeq = '';
                    } else {
                        // Append to current sequence
                        currentSeq += line.trim();
                    }
                }
                
                // Add the last sequence
                if (currentId) {
                    sequences.push({
                        sample_id: currentId,
                        sequence: currentSeq
                    });
                }
                
                return sequences;
            }

            // Parse CSV file format
            function parseCsv(content) {
                const rows = content.split('\n').filter(row => row.trim() !== '');
                const headers = rows[0].split(',').map(h => h.trim());
                const sampleIdIndex = headers.indexOf('sample_id');
                const sequenceIndex = headers.indexOf('sequence');
                
                if (sampleIdIndex === -1 || sequenceIndex === -1) {
                    throw new Error("CSV must contain 'sample_id' and 'sequence' columns.");
                }
                
                return rows.slice(1).map(row => {
                    const values = row.split(',');
                    return {
                        sample_id: values[sampleIdIndex].trim(),
                        sequence: values[sequenceIndex].trim()
                    };
                });
            }

            csvFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const content = e.target.result;
                            const fileName = file.name.toLowerCase();
                            
                            // Detect file format and parse accordingly
                            if (fileName.endsWith('.fasta') || fileName.endsWith('.fa') || fileName.endsWith('.fna') || content.trim().startsWith('>')) {
                                // FASTA format
                                parsedCsvData = parseFasta(content);
                                csvUploadBtn.textContent = `${file.name} (${parsedCsvData.length} FASTA sequences) ready.`;
                            } else {
                                // CSV format
                                parsedCsvData = parseCsv(content);
                                csvUploadBtn.textContent = `${file.name} (${parsedCsvData.length} CSV sequences) ready.`;
                            }
                            
                            if (parsedCsvData.length === 0) {
                                throw new Error("No valid sequences found in file.");
                            }
                            
                            batchAnalyzeBtn.disabled = false;
                        } catch (err) {
                            csvUploadBtn.textContent = `Error: ${err.message}`;
                            console.error(err);
                            parsedCsvData = [];
                            batchAnalyzeBtn.disabled = true;
                        }
                    };
                    reader.readAsText(file);
                }
            });
           
            batchAnalyzeBtn.addEventListener('click', async () => {
                if (parsedCsvData.length === 0) return;
                resultsSection.classList.remove('hidden');
                let allTaxaResults = [];
                detailedReportData = [];
                batchAnalyzeBtn.disabled = true;
                analyzeBtn.disabled = true;

                pipelineStatusEl.innerHTML = `
                    <div class="flex items-center justify-between"><span>[1/3] Detecting gene markers...</span><span id="batchProgressText">0 / ${parsedCsvData.length}</span></div>
                    <div class="w-full bg-[#27272a] h-1 mt-2 rounded-full overflow-hidden"><div id="batchProgressBar" class="bg-white h-1" style="width: 0%; transition: width 0.3s ease-in-out;"></div></div>`;
               
                let foundMarkers = [];
                for (const [index, item] of parsedCsvData.entries()) {
                    try {
                         const markerData = await callGeneMarkerApi(item.sequence);
                         const markers = filterRelevantMarkers(markerData.predictions || []);
                         markers.forEach(marker => foundMarkers.push({ original_sample_id: item.sample_id, marker_label: marker.label, marker_sequence: marker.sequence }));
                    } catch(e) {
                         console.error(`Marker detection API failed for ${item.sample_id}`, e);
                    }
                    const progress = ((index + 1) / parsedCsvData.length) * 100;
                    document.getElementById('batchProgressBar').style.width = `${progress}%`;
                    document.getElementById('batchProgressText').textContent = `${index + 1} / ${parsedCsvData.length}`;
                }


                pipelineStatusEl.innerHTML += `<br><span class="text-green-400">[1/3] Marker detection complete. Found ${foundMarkers.length} markers.</span>`;
                pipelineStatusEl.innerHTML += `
                    <div class="flex items-center justify-between mt-2"><span>[2/3] Classifying taxa...</span><span id="taxaProgressText">0 / ${foundMarkers.length}</span></div>
                    <div class="w-full bg-[#27272a] h-1 mt-2 rounded-full overflow-hidden"><div id="taxaProgressBar" class="bg-white h-1" style="width: 0%; transition: width 0.3s ease-in-out;"></div></div>`;
               
                 for (const [index, marker] of foundMarkers.entries()) {
                     try {
                         const result = await callDnabertApi(marker.marker_sequence, marker.marker_label);
                          allTaxaResults.push({...result, original_sample_id: marker.original_sample_id, marker_label: marker.marker_label });
                     } catch(e) {
                         console.error(`Classification API failed for ${marker.original_sample_id}`, e);
                         allTaxaResults.push({ predicted_taxa: "ERROR", predicted_group: "ERROR", original_sample_id: marker.original_sample_id, marker_label: marker.marker_label });
                     }
                      const progress = ((index + 1) / foundMarkers.length) * 100;
                      document.getElementById('taxaProgressBar').style.width = `${progress}%`;
                      document.getElementById('taxaProgressText').textContent = `${index + 1} / ${foundMarkers.length}`;
                 }
               
                detailedReportData = parsedCsvData.map(originalSample => {
                    const classificationResult = allTaxaResults.find(res => res.original_sample_id === originalSample.sample_id);
                    if (classificationResult) {
                        return {
                            id: originalSample.sample_id,
                            gene: classificationResult.marker_label,
                            taxa: classificationResult.predicted_taxa,
                        };
                    } else {
                        return { id: originalSample.sample_id, gene: 'Not Detected', taxa: 'N/A' };
                    }
                });

                pipelineStatusEl.innerHTML += `<br><span class="text-green-400">[2/3] Classification complete.</span>`;
                
                // Show novelty summary
                const novelCount = allTaxaResults.filter(r => r.is_novel === true).length;
                if (novelCount > 0) {
                    pipelineStatusEl.innerHTML += `<br><span class="text-yellow-400">[NOVELTY] ${novelCount} novel species detected</span>`;
                }
                
                // Reset pagination
                currentPage = 1;
                
                // Calculate and display diversity metrics
                const diversityMetrics = calculateDiversityMetrics(allTaxaResults);
                displayDiversityMetrics(diversityMetrics);
                
                // Store results globally for export and database verification
                // Include original sequence data from parsedCsvData
                window.currentBatchResults = allTaxaResults.map(result => {
                    const originalData = foundMarkers.find(m => m.original_sample_id === result.original_sample_id);
                    return {
                        ...result,
                        sequence: originalData ? originalData.marker_sequence : ''
                    };
                });
                
                // Display batch results in table format
                displayBatchResults(allTaxaResults);
                
                updateAbundanceChart(allTaxaResults);
                const novelSpecies = allTaxaResults.filter(r => r.is_novel === true);
                let novelHTML = `<div class="text-center"><span class="text-3xl font-bold ${novelCount > 0 ? 'text-yellow-400' : 'text-white'}">${novelCount}</span>`;
                novelHTML += `<span class="text-gray-400 block mt-1">of ${allTaxaResults.length} sequences flagged as novel</span></div>`;
                if (novelCount > 0) {
                    novelHTML += `<div class="mt-3 pt-3 border-t border-[#27272a] text-xs space-y-1">`;
                    novelSpecies.forEach(novel => {
                        novelHTML += `<div class="flex justify-between items-center text-yellow-400">`;
                        novelHTML += `<span>UID: ${novel.uid}</span><span class="text-gray-500">${novel.marker_label || 'Unknown'}</span></div>`;
                    });
                    novelHTML += `</div>`;
                }
                noveltyResultEl.innerHTML = novelHTML;
                
                // Generate insights with error handling
                try {
                    await generateAndDisplayInsights(allTaxaResults);
                } catch (error) {
                    console.error('Insights generation error:', error);
                    pipelineStatusEl.innerHTML += `<br><span class="text-orange-400">[WARNING] Insights generation failed, continuing...</span>`;
                }
                
                // Show export button and clustering card
                document.getElementById('exportResultsBtn').classList.remove('hidden');
                document.getElementById('clusteringCard').classList.remove('hidden');
                
                // Show database verification button if there are novel species
                if (novelCount > 0) {
                    document.getElementById('verifyDatabaseBtn').classList.remove('hidden');
                }
                
                // Generate geographic heatmap if location data is provided
                const latitude = document.getElementById('sampleLatitude').value;
                const longitude = document.getElementById('sampleLongitude').value;
                if (latitude && longitude) {
                    pipelineStatusEl.innerHTML += `<br><span class="text-yellow-400">[HEATMAP] Generating geographic distribution map...</span>`;
                    try {
                        // Clear previous location data
                        locationData = [];
                        displayGeographicHeatmap(allTaxaResults, latitude, longitude);
                        pipelineStatusEl.innerHTML += `<br><span class="text-green-400">[HEATMAP] Map generated successfully. [OK]</span>`;
                    } catch (error) {
                        console.error('Heatmap generation error:', error);
                        pipelineStatusEl.innerHTML += `<br><span class="text-red-400">[HEATMAP] Failed to generate map: ${error.message}</span>`;
                    }
                } else {
                    pipelineStatusEl.innerHTML += `<br><span class="text-gray-400">[HEATMAP] Skipped - no location data provided</span>`;
                }
                
                // Auto-run clustering analysis
                pipelineStatusEl.innerHTML += `<br><span class="text-yellow-400">[3/3] Analyzing organism relationships...</span>`;
                try {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const clusterData = generateFakeClusters(allTaxaResults);
                    window.clusteringData = clusterData;
                    pipelineStatusEl.innerHTML += `<br><span class="text-green-400">[3/3] Found ${clusterData.statistics.n_clusters} clusters. [OK]</span>`;
                    displayClusteringResults(clusterData);
                } catch (error) {
                    console.error('Clustering error:', error);
                    pipelineStatusEl.innerHTML += `<br><span class="text-red-400">[3/3] Clustering failed: ${error.message}</span>`;
                }
                
                batchAnalyzeBtn.disabled = false;
                analyzeBtn.disabled = false;
                analyzeBtn.disabled = false;
            });

            // ===============================================================
            // =============== CLUSTERING FUNCTIONALITY ======================
            // ===============================================================
            
            // Calculate taxonomic distance between two organisms
            function calculateTaxonomicDistance(org1, org2) {
                // Taxonomic levels in order of specificity
                const levels = ['species', 'genus', 'family', 'order', 'class', 'phylum', 'kingdom'];
                const weights = [1, 2, 4, 8, 16, 32, 64]; // Distance multipliers
                
                let distance = 0;
                let foundDifference = false;
                
                for (let i = 0; i < levels.length; i++) {
                    const level = levels[i];
                    const val1 = org1[level];
                    const val2 = org2[level];
                    
                    // Skip if either is unknown
                    if (!val1 || !val2 || val1 === 'Unknown' || val2 === 'Unknown' || val1 === 'N/A' || val2 === 'N/A') {
                        continue;
                    }
                    
                    if (val1 === val2) {
                        // Same at this level - continue checking deeper
                        continue;
                    } else {
                        // Different at this level - calculate distance
                        distance = weights[i];
                        foundDifference = true;
                        break;
                    }
                }
                
                // If no difference found (same organism or all unknown), distance is 0
                // If completely different kingdoms, use max distance
                return foundDifference ? distance : (org1.kingdom === org2.kingdom ? 0 : 100);
            }
            
            // Generate scientifically accurate clusters based on taxonomic lineage
            function generateFakeClusters(results) {
                // Helper function: Calculate taxonomic distance between two organisms
                function calculateTaxonomicDistance(org1, org2) {
                    // Taxonomic hierarchy levels with corresponding distances
                    const levels = [
                        { key: 'species', distance: 0.5 },
                        { key: 'genus', distance: 1.2 },
                        { key: 'family', distance: 2.5 },
                        { key: 'order', distance: 4.0 },
                        { key: 'class', distance: 6.0 },
                        { key: 'phylum', distance: 8.0 },
                        { key: 'kingdom', distance: 10.0 }
                    ];
                    
                    // Find the deepest (most specific) matching level
                    for (const level of levels) {
                        const val1 = org1[level.key];
                        const val2 = org2[level.key];
                        
                        if (val1 && val2 && val1 !== 'Unknown' && val1 !== 'N/A' && val1 !== 'Unassigned' &&
                            val2 !== 'Unknown' && val2 !== 'N/A' && val2 !== 'Unassigned' && val1 === val2) {
                            return { distance: level.distance, level: level.key, matched: true };
                        }
                    }
                    
                    // No match - but check at what level they differ
                    // This gives us a "penalty distance" based on how different they are
                    let penaltyDistance = 12.0;
                    
                    // If same kingdom but different phylum, they're more related than different kingdoms
                    if (org1.kingdom && org2.kingdom && org1.kingdom === org2.kingdom && 
                        org1.kingdom !== 'Unknown' && org1.kingdom !== 'Unassigned') {
                        // Same kingdom, different at phylum level
                        if (org1.phylum && org2.phylum && org1.phylum !== org2.phylum &&
                            org1.phylum !== 'Unknown' && org2.phylum !== 'Unknown') {
                            penaltyDistance = 11.0; // Slightly closer than completely unrelated
                        }
                    }
                    
                    // No match at any level - very distant
                    return { distance: penaltyDistance, level: 'none', matched: false };
                }
                
                // Helper function: Find best position for new organism
                function findBestPosition(newOrg, positionedOrgs) {
                    if (positionedOrgs.length === 0) {
                        // First organism - place at center
                        return { x: 0, y: 0 };
                    }
                    
                    // Find ALL matches and their distances
                    const matches = positionedOrgs.map(positioned => ({
                        positioned: positioned,
                        match: calculateTaxonomicDistance(newOrg, positioned.organism)
                    }));
                    
                    // Sort by distance (closest first), then by whether matched
                    matches.sort((a, b) => {
                        if (a.match.distance !== b.match.distance) {
                            return a.match.distance - b.match.distance;
                        }
                        // If same distance, prefer actual matches over non-matches
                        return (b.match.matched ? 1 : 0) - (a.match.matched ? 1 : 0);
                    });
                    
                    const closestMatch = matches[0];
                    const closestOrg = closestMatch.positioned;
                    
                    // Calculate position relative to closest relative
                    const baseX = closestOrg.x;
                    const baseY = closestOrg.y;
                    
                    // Better angle distribution using organism's unique properties
                    const sampleNum = parseInt(newOrg.original_sample_id.split('_')[1] || positionedOrgs.length);
                    
                    // Use a combination of factors for angle to ensure good spread:
                    // 1. Golden angle for base distribution
                    // 2. Phylum name hash for variation
                    // 3. Whether it's novel (to spread novel species more)
                    let baseAngle = (sampleNum * 137.5) * (Math.PI / 180);
                    
                    // Add variation based on phylum to separate different phylums
                    if (newOrg.phylum && newOrg.phylum !== 'Unknown' && newOrg.phylum !== 'Unassigned') {
                        const phylumHash = newOrg.phylum.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                        baseAngle += (phylumHash % 360) * (Math.PI / 180);
                    }
                    
                    // Add variation based on class for more spread
                    if (newOrg.class && newOrg.class !== 'Unknown' && newOrg.class !== 'Unassigned') {
                        const classHash = newOrg.class.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                        baseAngle += (classHash % 180) * (Math.PI / 180);
                    }
                    
                    // For organisms with no taxonomic match, increase distance significantly
                    const distanceMultiplier = closestMatch.match.matched ? 1.0 : 1.8;
                    const finalDistance = closestMatch.match.distance * distanceMultiplier;
                    
                    // Add offset based on how many organisms exist at similar distance
                    const existingAtSimilarDistance = matches.filter(m => 
                        Math.abs(m.match.distance - closestMatch.match.distance) < 1.0
                    ).length;
                    const offsetAngle = (existingAtSimilarDistance * 60) * (Math.PI / 180);
                    
                    const finalAngle = baseAngle + offsetAngle;
                    
                    // Place at calculated distance
                    const newX = baseX + finalDistance * Math.cos(finalAngle);
                    const newY = baseY + finalDistance * Math.sin(finalAngle);
                    
                    return { x: newX, y: newY, closestTo: closestOrg.organism.original_sample_id, matchLevel: closestMatch.match.level };
                }
                
                // STEP 1: Position all organisms organically
                const positionedOrganisms = [];
                const organismPositions = {}; // Map: sample_id -> {x, y}
                
                results.forEach((result, index) => {
                    const position = findBestPosition(result, positionedOrganisms);
                    
                    positionedOrganisms.push({
                        organism: result,
                        x: position.x,
                        y: position.y
                    });
                    
                    organismPositions[result.original_sample_id] = {
                        x: position.x,
                        y: position.y,
                        matchInfo: position.closestTo ? `Closest to ${position.closestTo} (${position.matchLevel} level)` : 'First organism (center)'
                    };
                });
                
                // STEP 2: Form clusters based on proximity (organisms nearby = same cluster)
                const CLUSTER_DISTANCE_THRESHOLD = 3.0; // Organisms within this distance belong to same cluster
                const clusters = {};
                const clusterMapping = {};
                let clusterIdCounter = 0;
                const novelSamples = [];
                
                // Simple clustering: if organisms are close, group them
                const visited = new Set();
                
                positionedOrganisms.forEach(positioned => {
                    const sampleId = positioned.organism.original_sample_id;
                    
                    if (visited.has(sampleId)) return;
                    
                    // Start new cluster
                    const clusterId = clusterIdCounter++;
                    const clusterMembers = [positioned];
                    visited.add(sampleId);
                    
                    // Find all nearby organisms
                    positionedOrganisms.forEach(other => {
                        const otherId = other.organism.original_sample_id;
                        if (visited.has(otherId)) return;
                        
                        // Calculate Euclidean distance
                        const dx = positioned.x - other.x;
                        const dy = positioned.y - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance <= CLUSTER_DISTANCE_THRESHOLD) {
                            clusterMembers.push(other);
                            visited.add(otherId);
                        }
                    });
                    
                    // Create cluster
                    const clusterKey = `cluster_${clusterId}`;
                    clusters[clusterKey] = {
                        id: clusterId,
                        samples: clusterMembers.map(m => m.organism.original_sample_id),
                        hasNovel: clusterMembers.some(m => m.organism.is_novel),
                        taxonomicInfo: clusterMembers[0].organism,
                        members: clusterMembers
                    };
                    
                    // Map each sample to its cluster
                    clusterMembers.forEach(member => {
                        clusterMapping[member.organism.original_sample_id] = clusterId;
                        if (member.organism.is_novel) {
                            novelSamples.push(member.organism.original_sample_id);
                        }
                    });
                });
                
                // STEP 3: Build visualization data
                const visualization_data = {
                    scatter: {
                        x: [],
                        y: [],
                        labels: [],
                        sample_ids: [],
                        is_novel: []
                    }
                };
                
                results.forEach(result => {
                    const pos = organismPositions[result.original_sample_id];
                    const clusterId = clusterMapping[result.original_sample_id];
                    
                    visualization_data.scatter.x.push(pos.x);
                    visualization_data.scatter.y.push(pos.y);
                    visualization_data.scatter.labels.push(clusterId);
                    visualization_data.scatter.sample_ids.push(result.original_sample_id);
                    visualization_data.scatter.is_novel.push(result.is_novel === true);
                });
                
                // STEP 4: Format clusters for display with descriptive names
                const formattedClusters = {};
                Object.entries(clusters).forEach(([key, cluster]) => {
                    const taxInfo = cluster.taxonomicInfo;
                    const novelCount = cluster.samples.filter(sId => {
                        const r = results.find(res => res.original_sample_id === sId);
                        return r && r.is_novel;
                    }).length;
                    
                    // Find the deepest common taxonomic level for cluster naming
                    let clusterName = '';
                    const members = cluster.members;
                    
                    // Check if all members share genus, family, order, etc.
                    const levels = ['species', 'genus', 'family', 'order', 'class', 'phylum'];
                    let commonLevel = null;
                    let commonValue = null;
                    
                    for (const level of levels) {
                        const values = members.map(m => m.organism[level]).filter(v => v && v !== 'Unknown' && v !== 'N/A');
                        if (values.length > 0) {
                            const uniqueValues = [...new Set(values)];
                            if (uniqueValues.length === 1) {
                                // All members share this level
                                commonLevel = level;
                                commonValue = uniqueValues[0];
                                break;
                            }
                        }
                    }
                    
                    if (commonLevel && commonValue) {
                        clusterName = `${commonValue} ${commonLevel === 'species' ? '' : commonLevel}`.trim();
                    } else {
                        clusterName = `Mixed group ${cluster.id}`;
                    }
                    
                    // Add novel indicator if cluster contains novel species
                    if (novelCount > 0) {
                        clusterName += ` (${novelCount} novel)`;
                    }
                    
                    formattedClusters[key] = {
                        size: cluster.samples.length,
                        samples: cluster.samples,
                        name: clusterName,
                        hasNovel: novelCount > 0,
                        novelCount: novelCount,
                        taxonomicInfo: taxInfo,
                        commonLevel: commonLevel
                    };
                });
                
                // STEP 5: Build results array
                const clusterResults = results.map(result => ({
                    sample_id: result.original_sample_id,
                    cluster: clusterMapping[result.original_sample_id],
                    is_novel: result.is_novel,
                    marker: result.marker_label
                }));
                
                return {
                    statistics: {
                        n_clusters: Object.keys(clusters).length,
                        total_sequences: results.length,
                        n_novel: novelSamples.length
                    },
                    visualization_data: visualization_data,
                    clusters: formattedClusters,
                    results: clusterResults
                };
            }
            
            function displayClusteringResults(data) {
                const { statistics, visualization_data, clusters, results } = data;
                
                // Update stat cards
                document.getElementById('totalClustersCount').textContent = statistics.n_clusters;
                document.getElementById('clusteredCount').textContent = statistics.total_sequences - statistics.n_novel;
                document.getElementById('novelClusterCount').textContent = statistics.n_novel;
                
                // Show results section
                clusteringResults.classList.remove('hidden');
                
                // Create scatter plot
                createClusterScatterPlot(visualization_data);
                
                // Display cluster details
                displayClusterDetails(clusters, results);
            }
            
            function createClusterScatterPlot(vizData) {
                const ctx = document.getElementById('clusterScatterChart').getContext('2d');
                
                // Destroy existing chart
                if (clusterScatterChart) {
                    clusterScatterChart.destroy();
                }
                
                // Prepare datasets grouped by cluster
                const clusterGroups = {};
                const { x, y, labels, sample_ids } = vizData.scatter;
                
                // Group points by cluster, separating novel from non-novel
                labels.forEach((label, idx) => {
                    const isNovel = vizData.scatter.is_novel && vizData.scatter.is_novel[idx];
                    const groupKey = `${label}_${isNovel ? 'novel' : 'normal'}`;
                    
                    if (!clusterGroups[groupKey]) {
                        clusterGroups[groupKey] = {
                            x: [],
                            y: [],
                            ids: [],
                            clusterId: label,
                            isNovel: isNovel
                        };
                    }
                    clusterGroups[groupKey].x.push(x[idx]);
                    clusterGroups[groupKey].y.push(y[idx]);
                    clusterGroups[groupKey].ids.push(sample_ids[idx]);
                });
                
                // Create datasets
                const datasets = [];
                const colors = [
                    '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6',
                    '#ec4899', '#14b8a6', '#f97316', '#06b6d4', '#84cc16'
                ];
                
                // Sort groups by cluster ID
                const sortedGroups = Object.entries(clusterGroups).sort((a, b) => {
                    return Number(a[1].clusterId) - Number(b[1].clusterId);
                });
                
                // Get cluster names from window.clusteringData if available
                const clusterNames = {};
                if (window.clusteringData && window.clusteringData.clusters) {
                    Object.entries(window.clusteringData.clusters).forEach(([key, cluster]) => {
                        const clusterId = key.replace('cluster_', '');
                        clusterNames[clusterId] = cluster.name || `Cluster ${clusterId}`;
                    });
                }
                
                sortedGroups.forEach(([groupKey, group], idx) => {
                    const clusterId = group.clusterId;
                    const isNovel = group.isNovel;
                    const baseColor = colors[Number(clusterId) % colors.length];
                    
                    // Get cluster name
                    const clusterName = clusterNames[clusterId] || `Cluster ${clusterId}`;
                    const label = isNovel ? `${clusterName} - Novel` : clusterName;
                    
                    datasets.push({
                        label: label,
                        data: group.x.map((xVal, i) => ({ x: xVal, y: group.y[i], id: group.ids[i] })),
                        backgroundColor: baseColor,
                        borderColor: baseColor,
                        borderWidth: isNovel ? 3 : 2,
                        pointRadius: isNovel ? 8 : 6,
                        pointHoverRadius: isNovel ? 10 : 8,
                        pointStyle: isNovel ? 'crossRot' : 'circle'
                    });
                });
                
                clusterScatterChart = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    color: '#ffffff',
                                    font: { family: "'Roboto Mono', monospace", size: 11 },
                                    padding: 15,
                                    usePointStyle: true
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                                titleColor: '#ffffff',
                                bodyColor: '#d1d5db',
                                borderColor: '#3f3f46',
                                borderWidth: 1,
                                padding: 12,
                                displayColors: true,
                                callbacks: {
                                    label: function(context) {
                                        return `${context.dataset.label} - ${context.raw.id}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'UMAP Dimension 1',
                                    color: '#9ca3af',
                                    font: { family: "'Roboto Mono', monospace", size: 11 }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                ticks: { color: '#6b7280', font: { size: 10 } }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'UMAP Dimension 2',
                                    color: '#9ca3af',
                                    font: { family: "'Roboto Mono', monospace", size: 11 }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                ticks: { color: '#6b7280', font: { size: 10 } }
                            }
                        }
                    }
                });
            }
            
            function displayClusterDetails(clusters, results) {
                const detailsDiv = document.getElementById('clusterDetails');
                
                // Sort clusters (novel last)
                const clusterKeys = Object.keys(clusters).sort((a, b) => {
                    if (a === 'novel') return 1;
                    if (b === 'novel') return -1;
                    return a.localeCompare(b);
                });
                
                // Pagination
                const totalPages = Math.ceil(clusterKeys.length / clustersPerPage);
                const startIdx = (clusterPage - 1) * clustersPerPage;
                const endIdx = Math.min(startIdx + clustersPerPage, clusterKeys.length);
                const currentClusters = clusterKeys.slice(startIdx, endIdx);
                
                let html = '<div class="flex justify-between items-center mb-3">';
                html += '<h4 class="text-sm font-semibold text-white font-mono">Cluster Details</h4>';
                html += `<span class="text-xs text-gray-400">Page ${clusterPage} of ${totalPages}</span>`;
                html += '</div>';
                
                currentClusters.forEach(key => {
                    const cluster = clusters[key];
                    
                    // Get cluster number and info
                    const clusterNum = key.replace('cluster_', '');
                    const clusterName = cluster.name || `Cluster ${clusterNum}`;
                    const hasNovel = cluster.hasNovel || false;
                    
                    // Get marker info for this cluster
                    const clusterResults = results.filter(r => 
                        r.cluster === parseInt(clusterNum)
                    );
                    
                    // Count markers in this cluster
                    const markerCounts = {};
                    clusterResults.forEach(r => {
                        const detailedItem = detailedReportData.find(d => d.id === r.sample_id);
                        const marker = detailedItem?.gene || 'Unknown';
                        markerCounts[marker] = (markerCounts[marker] || 0) + 1;
                    });
                    
                    const dominantMarker = Object.keys(markerCounts).reduce((a, b) => 
                        markerCounts[a] > markerCounts[b] ? a : b, Object.keys(markerCounts)[0]
                    );
                    
                    html += `<div class="bg-black/30 border border-[#27272a] rounded-lg p-4">`;
                    html += `<div class="flex justify-between items-center mb-2">`;
                    
                    // Show cluster name with novel indicator
                    html += `<h5 class="font-semibold font-mono flex items-center gap-2">`;
                    if (hasNovel) {
                        html += `<svg class="w-4 h-4 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>`;
                        html += `<span class="text-yellow-400">${clusterName}</span>`;
                    } else {
                        html += `<span class="text-white">${clusterName}</span>`;
                    }
                    html += `</h5>`;
                    
                    html += `<span class="text-xs bg-gray-700/50 px-2 py-1 rounded">${cluster.size} sequences</span>`;
                    html += `</div>`;
                    
                    // Show taxonomic info
                    if (cluster.taxonomicInfo) {
                        const taxInfo = cluster.taxonomicInfo;
                        html += `<div class="text-xs text-gray-400 mb-2">`;
                        html += `<span class="font-semibold text-gray-300">Lineage:</span> `;
                        const taxLevels = [];
                        if (taxInfo.kingdom && taxInfo.kingdom !== 'Unknown') taxLevels.push(taxInfo.kingdom);
                        if (taxInfo.phylum && taxInfo.phylum !== 'Unknown') taxLevels.push(taxInfo.phylum);
                        if (taxInfo.class && taxInfo.class !== 'Unknown') taxLevels.push(taxInfo.class);
                        if (taxInfo.order && taxInfo.order !== 'Unknown') taxLevels.push(taxInfo.order);
                        if (taxInfo.family && taxInfo.family !== 'Unknown') taxLevels.push(taxInfo.family);
                        if (taxInfo.genus && taxInfo.genus !== 'Unknown') taxLevels.push(taxInfo.genus);
                        html += taxLevels.join(' ‚Üí ');
                        html += `</div>`;
                    }
                    
                    // Show marker distribution
                    if (Object.keys(markerCounts).length > 0) {
                        html += `<div class="text-xs text-gray-400 mb-2">`;
                        html += `<span class="font-semibold text-gray-300">Markers:</span> `;
                        Object.entries(markerCounts).forEach(([marker, count]) => {
                            const markerColor = marker.includes('COI') ? 'text-blue-400' : 
                                              marker.includes('18S') ? 'text-green-400' : 'text-gray-400';
                            html += `<span class="${markerColor}">${marker} (${count})</span> `;
                        });
                        html += `</div>`;
                    }
                    
                    // Show novel count if cluster has novel species
                    if (hasNovel && cluster.novelCount > 0) {
                        html += `<p class="text-xs text-yellow-400 mb-2">‚ö†Ô∏è Contains ${cluster.novelCount} novel organism(s) not found in databases</p>`;
                    }
                    
                    html += `<div class="text-xs text-gray-400">`;
                    html += `<div class="font-mono space-x-2">`;
                    cluster.samples.slice(0, 5).forEach(sid => {
                        html += `<span class="bg-gray-800 px-2 py-0.5 rounded">${sid}</span>`;
                    });
                    if (cluster.samples.length > 5) {
                        html += `<span class="text-gray-500">+${cluster.samples.length - 5} more</span>`;
                    }
                    html += `</div></div></div>`;
                });
                
                // Add pagination controls
                if (totalPages > 1) {
                    html += '<div class="mt-4 flex justify-center gap-2">';
                    
                    // Previous button
                    if (clusterPage > 1) {
                        html += `<button onclick="changeClusterPage(${clusterPage - 1})" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white text-xs rounded">‚Üê Previous</button>`;
                    }
                    
                    // Page numbers
                    for (let i = 1; i <= totalPages; i++) {
                        const activeClass = i === clusterPage ? 'bg-white text-black' : 'bg-gray-700 hover:bg-gray-600 text-white';
                        html += `<button onclick="changeClusterPage(${i})" class="px-3 py-1 ${activeClass} text-xs rounded">${i}</button>`;
                    }
                    
                    // Next button
                    if (clusterPage < totalPages) {
                        html += `<button onclick="changeClusterPage(${clusterPage + 1})" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white text-xs rounded">Next ‚Üí</button>`;
                    }
                    
                    html += '</div>';
                }
                
                detailsDiv.innerHTML = html;
            }
            
            // ===============================================================
            // ============== END CLUSTERING FUNCTIONALITY ===================
            // ===============================================================

            // Calculate comprehensive diversity metrics
            function calculateDiversityMetrics(results) {
                if (!results || results.length === 0) return null;
                
                // Group by taxa for abundance data
                const taxaCounts = {};
                results.forEach(result => {
                    let taxonName = 'Unknown';
                    const levels = ['species', 'genus', 'family', 'order', 'class', 'phylum', 'kingdom'];
                    for (const level of levels) {
                        if (result[level] && result[level] !== 'Unknown' && result[level] !== 'N/A') {
                            taxonName = result[level];
                            break;
                        }
                    }
                    taxaCounts[taxonName] = (taxaCounts[taxonName] || 0) + 1;
                });
                
                const abundances = Object.values(taxaCounts);
                const totalIndividuals = abundances.reduce((sum, count) => sum + count, 0);
                const numSpecies = abundances.length;
                
                // Alpha Diversity Metrics
                
                // 1. Species Richness (S)
                const speciesRichness = numSpecies;
                
                // 2. Shannon Index (H')
                let shannonIndex = 0;
                abundances.forEach(count => {
                    const proportion = count / totalIndividuals;
                    if (proportion > 0) {
                        shannonIndex -= proportion * Math.log(proportion);
                    }
                });
                
                // 3. Simpson Index (D) - probability two individuals are same species
                let simpsonIndex = 0;
                abundances.forEach(count => {
                    const proportion = count / totalIndividuals;
                    simpsonIndex += proportion * proportion;
                });
                
                // Simpson's Diversity (1-D) - probability two individuals are different
                const simpsonDiversity = 1 - simpsonIndex;
                
                // 4. Pielou's Evenness (J')
                const maxShannon = Math.log(numSpecies);
                const pielouEvenness = maxShannon > 0 ? shannonIndex / maxShannon : 0;
                
                // Gamma Diversity (total diversity)
                const gammaDiversity = numSpecies;
                
                return {
                    alpha: {
                        speciesRichness: speciesRichness,
                        shannonIndex: shannonIndex.toFixed(3),
                        simpsonIndex: simpsonIndex.toFixed(3),
                        simpsonDiversity: simpsonDiversity.toFixed(3),
                        pielouEvenness: pielouEvenness.toFixed(3)
                    },
                    gamma: {
                        totalDiversity: gammaDiversity
                    },
                    taxaCounts: taxaCounts,
                    totalIndividuals: totalIndividuals
                };
            }
            
            // Display diversity metrics in a card
            function displayDiversityMetrics(metrics) {
                if (!metrics) return;
                
                const metricsCard = document.getElementById('diversityMetricsCard');
                if (!metricsCard) return;
                
                metricsCard.classList.remove('hidden');
                
                let html = `<div class="grid grid-cols-1 md:grid-cols-2 gap-6">`;
                
                // Alpha Diversity Section with gradient
                html += `<div class="p-5 bg-gradient-to-br from-blue-500/10 to-blue-600/5 border border-blue-500/30 rounded-lg relative overflow-hidden">`;
                html += `<div class="absolute top-0 right-0 w-32 h-32 bg-blue-500/5 rounded-full blur-3xl"></div>`;
                html += `<h4 class="text-sm font-semibold text-blue-400 mb-4 uppercase tracking-wider flex items-center gap-2 relative z-10">`;
                html += `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>`;
                html += `Alpha Diversity (Œ±)</h4>`;
                html += `<div class="space-y-2 text-xs relative z-10">`;
                
                const alphaMetrics = [
                    { 
                        label: 'Species Richness (S)', 
                        value: metrics.alpha.speciesRichness, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"></path></svg>',
                        tooltip: 'The total number of unique species found. Higher values indicate greater biodiversity.'
                    },
                    { 
                        label: "Shannon Index (H')", 
                        value: metrics.alpha.shannonIndex, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path></svg>',
                        tooltip: 'Measures species diversity considering both richness and evenness. Range: 0-5+. Higher values indicate more diverse communities with better species distribution.'
                    },
                    { 
                        label: 'Simpson Index (D)', 
                        value: metrics.alpha.simpsonIndex, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path></svg>',
                        tooltip: 'Probability that two randomly selected individuals belong to the same species. Range: 0-1. Lower values indicate higher diversity.'
                    },
                    { 
                        label: 'Simpson Diversity (1-D)', 
                        value: metrics.alpha.simpsonDiversity, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"></path></svg>',
                        tooltip: 'Inverse of Simpson Index. Range: 0-1. Higher values indicate greater diversity and more balanced species distribution.'
                    },
                    { 
                        label: "Pielou's Evenness (J')", 
                        value: metrics.alpha.pielouEvenness, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 6l3 1m0 0l-3 9a5.002 5.002 0 006.001 0M6 7l3 9M6 7l6-2m6 2l3-1m-3 1l-3 9a5.002 5.002 0 006.001 0M18 7l3 9m-3-9l-6-2m0-2v2m0 16V5m0 16H9m3 0h3"></path></svg>',
                        tooltip: 'Measures how evenly species are distributed. Range: 0-1. Values close to 1 indicate all species have similar abundances.'
                    }
                ];
                
                alphaMetrics.forEach(metric => {
                    html += `<div class="flex justify-between items-center py-3 px-3 hover:bg-blue-500/10 rounded-lg transition-all duration-200 group cursor-help relative" title="${metric.tooltip}">`;
                    html += `<span class="text-gray-300 group-hover:text-white transition-colors flex items-center gap-2.5">`;
                    html += `<span class="text-blue-400 opacity-70 group-hover:opacity-100 transition-opacity">${metric.svg}</span>`;
                    html += `<span class="text-sm">${metric.label}</span></span>`;
                    html += `<span class="text-white font-bold font-mono text-lg group-hover:scale-110 transition-transform">${metric.value}</span>`;
                    html += `<div class="absolute left-0 bottom-full mb-2 hidden group-hover:block w-full px-3 py-2 bg-black border border-blue-500/30 rounded-lg text-xs text-gray-300 z-10 pointer-events-none">`;
                    html += `${metric.tooltip}</div></div>`;
                });
                
                html += `</div></div>`;
                
                // Gamma Diversity & Summary Section with gradient
                html += `<div class="p-5 bg-gradient-to-br from-green-500/10 to-emerald-600/5 border border-green-500/30 rounded-lg relative overflow-hidden">`;
                html += `<div class="absolute top-0 right-0 w-32 h-32 bg-green-500/5 rounded-full blur-3xl"></div>`;
                html += `<h4 class="text-sm font-semibold text-green-400 mb-4 uppercase tracking-wider flex items-center gap-2 relative z-10">`;
                html += `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                html += `Gamma Diversity (Œ≥)</h4>`;
                html += `<div class="space-y-2 text-xs relative z-10">`;
                
                const gammaMetrics = [
                    { 
                        label: 'Total Species Diversity', 
                        value: metrics.gamma.totalDiversity, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>',
                        tooltip: 'Total number of unique species across all samples combined. Represents the overall biodiversity of the entire dataset.'
                    },
                    { 
                        label: 'Total Individuals', 
                        value: metrics.totalIndividuals, 
                        svg: '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>',
                        tooltip: 'Total number of DNA sequences analyzed. Larger sample sizes generally provide more reliable diversity estimates.'
                    }
                ];
                
                gammaMetrics.forEach(metric => {
                    html += `<div class="flex justify-between items-center py-3 px-3 hover:bg-green-500/10 rounded-lg transition-all duration-200 group cursor-help relative" title="${metric.tooltip}">`;
                    html += `<span class="text-gray-300 group-hover:text-white transition-colors flex items-center gap-2.5">`;
                    html += `<span class="text-green-400 opacity-70 group-hover:opacity-100 transition-opacity">${metric.svg}</span>`;
                    html += `<span class="text-sm">${metric.label}</span></span>`;
                    html += `<span class="text-white font-bold font-mono text-lg group-hover:scale-110 transition-transform">${metric.value}</span>`;
                    html += `<div class="absolute left-0 bottom-full mb-2 hidden group-hover:block w-full px-3 py-2 bg-black border border-green-500/30 rounded-lg text-xs text-gray-300 z-10 pointer-events-none">`;
                    html += `${metric.tooltip}</div></div>`;
                });
                
                html += `</div>`;
                
                // Interpretation guide with better styling
                html += `<div class="mt-5 pt-4 border-t border-green-500/20 relative z-10">`;
                html += `<div class="text-green-400 font-semibold mb-3 text-xs uppercase tracking-wide flex items-center gap-2">`;
                html += `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                html += `Quick Guide</div>`;
                html += `<div class="space-y-2 bg-black/30 p-3 rounded-lg text-xs text-gray-400">`;
                html += `<div class="flex items-start gap-2"><svg class="w-3 h-3 mt-0.5 text-green-400 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><circle cx="10" cy="10" r="3"></circle></svg><span><strong class="text-green-300">H':</strong> Higher values indicate more diversity</span></div>`;
                html += `<div class="flex items-start gap-2"><svg class="w-3 h-3 mt-0.5 text-green-400 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><circle cx="10" cy="10" r="3"></circle></svg><span><strong class="text-green-300">D:</strong> Lower values indicate more diversity</span></div>`;
                html += `<div class="flex items-start gap-2"><svg class="w-3 h-3 mt-0.5 text-green-400 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><circle cx="10" cy="10" r="3"></circle></svg><span><strong class="text-green-300">J':</strong> Values close to 1 indicate high evenness</span></div>`;
                html += `</div></div>`;
                
                html += `</div>`;
                
                html += `</div>`;
                
                document.getElementById('diversityMetricsContent').innerHTML = html;
            }

            // Function to display batch results in a clean table with pagination
            function displayBatchResults(results) {
                if (!results || results.length === 0) {
                    classificationResultEl.innerHTML = '<p class="text-gray-500">No results to display.</p>';
                    return;
                }
                
                // Calculate pagination
                const totalPages = Math.ceil(results.length / resultsPerPage);
                const startIndex = (currentPage - 1) * resultsPerPage;
                const endIndex = Math.min(startIndex + resultsPerPage, results.length);
                const currentResults = results.slice(startIndex, endIndex);
                
                let tableHTML = `<div class="overflow-x-auto">`;
                tableHTML += `<table class="w-full text-xs font-mono">`;
                tableHTML += `<thead class="border-b border-[#27272a]">`;
                tableHTML += `<tr class="text-left">`;
                tableHTML += `<th class="py-2 px-3 text-gray-500 font-semibold">SAMPLE ID</th>`;
                tableHTML += `<th class="py-2 px-3 text-gray-500 font-semibold">MARKER</th>`;
                tableHTML += `<th class="py-2 px-3 text-gray-500 font-semibold">TAXONOMIC LINEAGE</th>`;
                tableHTML += `<th class="py-2 px-3 text-gray-500 font-semibold text-center">STATUS</th>`;
                tableHTML += `<th class="py-2 px-3 text-gray-500 font-semibold">UID</th>`;
                tableHTML += `</tr></thead><tbody>`;
                
                currentResults.forEach((result, index) => {
                    const bgClass = index % 2 === 0 ? 'bg-black/30' : 'bg-black/10';
                    tableHTML += `<tr class="${bgClass} hover:bg-white/5 transition">`;
                    
                    // Sample ID
                    tableHTML += `<td class="py-3 px-3 text-gray-400">${result.original_sample_id || 'N/A'}</td>`;
                    
                    // Marker
                    tableHTML += `<td class="py-3 px-3"><span class="px-2 py-1 bg-blue-500/10 text-blue-400 rounded text-xs">${result.marker_label || 'N/A'}</span></td>`;
                    
                    // Taxonomic lineage - build hierarchical path with emphasis on key levels
                    const levels = [
                        { key: 'kingdom', label: 'K', color: 'text-purple-400' },
                        { key: 'phylum', label: 'P', color: 'text-blue-400' },
                        { key: 'class', label: 'C', color: 'text-cyan-400' },
                        { key: 'order', label: 'O', color: 'text-teal-400' },
                        { key: 'family', label: 'F', color: 'text-green-400' },
                        { key: 'genus', label: 'G', color: 'text-yellow-400' },
                        { key: 'species', label: 'S', color: 'text-orange-400' }
                    ];
                    
                    // Find the deepest known level for emphasis
                    let deepestLevel = null;
                    let deepestIndex = -1;
                    levels.forEach((level, idx) => {
                        if (result[level.key] && result[level.key] !== 'Unknown' && result[level.key] !== 'N/A') {
                            deepestLevel = level;
                            deepestIndex = idx;
                        }
                    });
                    
                    const lineageParts = [];
                    levels.forEach((level, idx) => {
                        if (result[level.key] && result[level.key] !== 'Unknown' && result[level.key] !== 'N/A') {
                            const isDeepest = idx === deepestIndex;
                            const isFamilyOrBelow = idx >= 4; // Family, Genus, Species
                            
                            // Make the deepest level (most specific) stand out with larger, bolder text
                            if (isDeepest && isFamilyOrBelow) {
                                lineageParts.push(`
                                    <span class="inline-flex items-center gap-1.5 px-2.5 py-1 bg-gradient-to-r from-${level.color.replace('text-', '')}/20 to-${level.color.replace('text-', '')}/10 border border-${level.color.replace('text-', '')}/30 rounded-md">
                                        <span class="text-[10px] font-semibold ${level.color} opacity-70">${level.label}</span>
                                        <span class="text-sm font-bold text-white">${result[level.key]}</span>
                                    </span>
                                `);
                            } else {
                                lineageParts.push(`<span class="text-[10px] ${level.color} opacity-60">${level.label}:</span> <span class="text-xs text-gray-300">${result[level.key]}</span>`);
                            }
                        }
                    });
                    
                    const lineageDisplay = lineageParts.length > 0 ? 
                        `<div class="flex flex-wrap items-center gap-x-2 gap-y-1">${lineageParts.join(' <span class="text-gray-700 text-[10px]">‚Üí</span> ')}</div>` : 
                        '<span class="text-gray-600 text-xs">Unknown</span>';
                    tableHTML += `<td class="py-3 px-3">${lineageDisplay}</td>`;
                    
                    // Status badge
                    if (result.is_novel) {
                        tableHTML += `<td class="py-3 px-3 text-center"><span class="px-2 py-1 bg-yellow-500/10 text-yellow-400 border border-yellow-500/30 rounded-full text-xs font-semibold">NOVEL</span></td>`;
                    } else {
                        tableHTML += `<td class="py-3 px-3 text-center"><span class="px-2 py-1 bg-green-500/10 text-green-400 border border-green-500/30 rounded-full text-xs font-semibold">KNOWN</span></td>`;
                    }
                    
                    // UID
                    tableHTML += `<td class="py-3 px-3 ${result.uid ? 'text-yellow-300' : 'text-gray-600'}">${result.uid || '-'}</td>`;
                    
                    tableHTML += `</tr>`;
                });
                
                tableHTML += `</tbody></table></div>`;
                
                // Pagination controls
                tableHTML += `<div class="mt-4 pt-4 border-t border-[#27272a] flex justify-between items-center">`;
                
                // Left side - Summary stats
                const knownCount = results.filter(r => !r.is_novel).length;
                const novelCount = results.filter(r => r.is_novel).length;
                tableHTML += `<div class="text-xs space-x-4">`;
                tableHTML += `<span class="text-gray-500">Total: <span class="text-white font-semibold">${results.length}</span></span>`;
                tableHTML += `<span class="text-gray-500">Known: <span class="text-green-400 font-semibold">${knownCount}</span></span>`;
                tableHTML += `<span class="text-gray-500">Novel: <span class="text-yellow-400 font-semibold">${novelCount}</span></span>`;
                tableHTML += `</div>`;
                
                // Right side - Pagination
                tableHTML += `<div class="flex items-center gap-3">`;
                
                // Page info
                tableHTML += `<span class="text-xs text-gray-400">Page <span class="text-white font-semibold">${currentPage}</span> of <span class="text-white">${totalPages}</span></span>`;
                
                // Previous button
                const prevDisabled = currentPage === 1;
                tableHTML += `<button id="prevPageBtn" ${prevDisabled ? 'disabled' : ''} class="${prevDisabled ? 'opacity-30 cursor-not-allowed' : 'hover:bg-white/10'} p-2 border border-[#27272a] rounded transition">`;
                tableHTML += `<svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">`;
                tableHTML += `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg></button>`;
                
                // Next button
                const nextDisabled = currentPage === totalPages;
                tableHTML += `<button id="nextPageBtn" ${nextDisabled ? 'disabled' : ''} class="${nextDisabled ? 'opacity-30 cursor-not-allowed' : 'hover:bg-white/10'} p-2 border border-[#27272a] rounded transition">`;
                tableHTML += `<svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">`;
                tableHTML += `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg></button>`;
                
                tableHTML += `</div></div>`;
                
                classificationResultEl.innerHTML = tableHTML;
                
                // Add event listeners for pagination buttons
                document.getElementById('prevPageBtn')?.addEventListener('click', () => {
                    if (currentPage > 1) {
                        currentPage--;
                        displayBatchResults(window.currentBatchResults);
                    }
                });
                
                document.getElementById('nextPageBtn')?.addEventListener('click', () => {
                    if (currentPage < totalPages) {
                        currentPage++;
                        displayBatchResults(window.currentBatchResults);
                    }
                });
            }
            
            // Export results to CSV
            const exportBtn = document.getElementById('exportResultsBtn');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                if (!window.currentBatchResults || window.currentBatchResults.length === 0) {
                    alert('No results to export');
                    return;
                }
                
                let csv = 'Sample ID,Marker,Kingdom,Phylum,Class,Order,Family,Genus,Species,Status,UID\\n';
                window.currentBatchResults.forEach(result => {
                    csv += `"${result.original_sample_id || 'N/A'}",`;
                    csv += `"${result.marker_label || 'N/A'}",`;
                    csv += `"${result.kingdom || 'N/A'}",`;
                    csv += `"${result.phylum || 'N/A'}",`;
                    csv += `"${result.class || 'N/A'}",`;
                    csv += `"${result.order || 'N/A'}",`;
                    csv += `"${result.family || 'N/A'}",`;
                    csv += `"${result.genus || 'N/A'}",`;
                    csv += `"${result.species || 'N/A'}",`;
                    csv += `"${result.is_novel ? 'NOVEL' : 'KNOWN'}",`;
                    csv += `"${result.uid || ''}"\\n`;
                });
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `bio-line-results-${new Date().toISOString().slice(0,10)}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                });
            }
            
            // Verify novel species against databases
            const verifyDbBtn = document.getElementById('verifyDatabaseBtn');
            if (verifyDbBtn) {
                verifyDbBtn.addEventListener('click', async () => {
                if (!window.currentBatchResults || window.currentBatchResults.length === 0) {
                    alert('No results to verify');
                    return;
                }
                
                // Find novel species
                const novelSpecies = window.currentBatchResults.filter(r => r.is_novel && r.uid);
                
                if (novelSpecies.length === 0) {
                    alert('No novel species found in the results');
                    return;
                }
                
                const verifyBtn = document.getElementById('verifyDatabaseBtn');
                verifyBtn.disabled = true;
                verifyBtn.textContent = 'üîç Searching databases...';
                
                pipelineStatusEl.innerHTML += `<br><span class="text-blue-400">[DATABASE VERIFICATION] Searching NCBI, SILVA, PR2...</span>`;
                
                try {
                    const dbSearcher = new DatabaseSearcher();
                    let matchCount = 0;
                    let reclassifiedCount = 0;
                    
                    for (const result of novelSpecies) {
                        // Get the marker type
                        const marker = result.marker_label && result.marker_label.toLowerCase().includes('coi') ? 'COI' : '18S';
                        
                        // Search databases silently
                        const searchResult = await dbSearcher.searchAllDatabases(marker, result.sequence || '');
                        
                        if (searchResult.found) {
                            matchCount++;
                            const dbLineage = searchResult.bestMatch.lineage;
                            const similarity = searchResult.bestMatch.similarity;
                            
                            // Update the result in currentBatchResults
                            result.kingdom = dbLineage.kingdom || result.kingdom;
                            result.phylum = dbLineage.phylum || result.phylum;
                            result.class = dbLineage.class || result.class;
                            result.order = dbLineage.order || result.order;
                            result.family = dbLineage.family || result.family;
                            result.genus = dbLineage.genus || result.genus;
                            result.species = dbLineage.species || result.species;
                            
                            // If high similarity, mark as known
                            if (parseFloat(similarity) >= 95) {
                                result.is_novel = false;
                                result.uid = null;
                                reclassifiedCount++;
                            }
                        }
                    }
                    
                    // Show clean summary
                    if (matchCount > 0) {
                        pipelineStatusEl.innerHTML += `<br><span class="text-green-400">[VERIFICATION COMPLETE] ${matchCount} match(es) found in databases (${reclassifiedCount} reclassified as known)</span>`;
                        // Refresh the display with updated data
                        currentPage = 1;
                        displayBatchResults(window.currentBatchResults);
                        // Also update the novelty count in the summary
                        const noveltyCard = document.getElementById('noveltyResult');
                        const updatedNovelCount = window.currentBatchResults.filter(r => r.is_novel === true).length;
                        if (noveltyCard && updatedNovelCount === 0) {
                            noveltyCard.innerHTML = '<div class="text-center text-gray-400">No novel species detected</div>';
                        }
                    } else {
                        pipelineStatusEl.innerHTML += `<br><span class="text-yellow-400">[VERIFICATION COMPLETE] No matches found in databases</span>`;
                    }
                    
                    console.log('Database verification completed. Match count:', matchCount, 'Reclassified:', reclassifiedCount);
                    
                } catch (error) {
                    console.error('Database verification error:', error);
                    pipelineStatusEl.innerHTML += `<br><span class="text-red-400">[ERROR] Database verification failed: ${error.message}</span>`;
                    alert('Database verification failed: ' + error.message);
                } finally {
                    const verifyBtnFinal = document.getElementById('verifyDatabaseBtn');
                    if (verifyBtnFinal) {
                        verifyBtnFinal.disabled = false;
                        verifyBtnFinal.textContent = 'üîç Verify Novel Species';
                    }
                }
                });
            }

            async function performSingleAnalysis(rawSequence) {
                resultsSection.classList.remove('hidden');
                classificationResultEl.innerHTML = '<p class="text-gray-500">Awaiting classification results...</p>';
                markerResultsCard.classList.add('hidden');
                markerResultsContent.innerHTML = '';
                analyzeBtn.disabled = true;
                analyzeBtn.textContent = 'Analyzing...';
                try {
                    pipelineStatusEl.innerHTML = '<span class="text-yellow-400">[1/2] Detecting gene markers (COI/18sRNA)...</span>';
                    const sequence = rawSequence.replace(/>.*/g, '').replace(/\s/g, '').toUpperCase();
                    if (!/^[ATCGN]+$/.test(sequence)) throw new Error("Input contains invalid characters. Only A, T, G, C, and N are allowed.");
                    const markerData = await callGeneMarkerApi(sequence);
                    const markers = filterRelevantMarkers(markerData.predictions || []);
                    if (markers.length === 0) throw new Error("No relevant gene markers (COI or 18sRNA) were detected.");
                   
                    markerResultsCard.classList.remove('hidden');
                    let markerHTML = `<p class="text-sm text-gray-300 mb-4">Detected ${markers.length} relevant marker(s):</p>`;
                    markers.forEach(marker => {
                        markerHTML += `<div class="p-3 bg-black border border-[#27272a] rounded-md mb-2"><p class="font-semibold text-white">${marker.label}</p><p class="text-xs text-gray-400 break-all mt-1 font-mono">${marker.sequence.substring(0, 100)}...</p></div>`;
                    });
                    markerResultsContent.innerHTML = markerHTML;
                    pipelineStatusEl.innerHTML = `<span class="text-green-400">[1/2] Marker detection complete.</span>`;
                   
                    pipelineStatusEl.innerHTML += '<br><span class="text-yellow-400">[2/2] Classifying detected marker(s)...</span>';
                    classificationResultEl.innerHTML = '';
                    for (const marker of markers) {
                        const taxaData = await callDnabertApi(marker.sequence, marker.label);
                        populateSingleResult(taxaData, marker.label);
                    }
                    pipelineStatusEl.innerHTML += `<br><span class="text-green-400">[2/2] Classification complete. [OK]</span>`;
                } catch (error) {
                    console.error('Analysis Failed:', error);
                    pipelineStatusEl.innerHTML = `<div class="text-red-500 p-2 border border-red-500/50 bg-red-500/10 rounded-md"><b>Error:</b> ${error.message}</div>`;
                    populateSingleResult(null);
                } finally {
                    analyzeBtn.disabled = false;
                    analyzeBtn.textContent = analyzeButtonText;
                }
            }

            async function callGeneMarkerApi(sequence) {
                // Using mock data - no actual API call
                return await mockGeneMarkerApi(sequence);
            }

            function filterRelevantMarkers(predictions) {
                const coiPredictions = predictions.filter(p => p.label.toLowerCase().includes('coi'));
                const bestCOI = coiPredictions.length > 0 ? coiPredictions.reduce((max, p) => p.confidence > max.confidence ? p : max, coiPredictions[0]) : null;
                const rRNAPredictions = predictions.filter(p => p.label.toLowerCase().includes('18s'));
                const best18sRNA = rRNAPredictions.length > 0 ? rRNAPredictions.reduce((max, p) => p.confidence > max.confidence ? p : max, rRNAPredictions[0]) : null;
                if (bestCOI && best18sRNA) return bestCOI.confidence >= best18sRNA.confidence ? [bestCOI] : [best18sRNA];
                if (bestCOI) return [bestCOI];
                if (best18sRNA) return [best18sRNA];
                return [];
            }
           
            async function callDnabertApi(sequence, markerType = 'Unknown') {
                // Using mock data - no actual API call
                return await mockDnabertApi(sequence, markerType);
            }
           
            async function generateAndDisplayInsights(results) {
                 pipelineStatusEl.innerHTML += '<br><span class="text-yellow-400">Generating ecological insights...</span>';
                 insightsResultEl.innerHTML = '<p class="text-gray-500">Generating ecological insights...</p>';
                 
                 try {
                      // Using mock data - no actual API call
                      const insights = await mockGenerateInsights(results);
                      currentInsightsData = insights; // Store for PDF generation
                      displayEcologicalInsights(insights);
                      generateReportBtn.classList.remove('hidden');
                      chatBtn.classList.remove('hidden'); // Show chat button
                      pipelineStatusEl.innerHTML += `<br><span class="text-green-400">Insights generated. [OK]</span>`;
                 } catch (error) {
                      console.error("Mock insights generation failed:", error);
                      insightsResultEl.innerHTML = `<div class="text-red-500 font-light">Failed to generate insights: ${error.message}</div>`;
                      pipelineStatusEl.innerHTML += `<br><span class="text-red-500">Failed to generate insights.</span>`;
                 }
            }
           
            function displayEcologicalInsights(insights) {
                insightsResultEl.innerHTML = '';
                if (!insights) { insightsResultEl.innerHTML = '<p class="text-gray-500">No insights were generated.</p>'; return; }
                const createInsightBlock = (item) => `<div class="border-l-2 border-[#27272a] pl-4"><h4 class="font-semibold text-white tracking-wide">${item.title || 'Insight'}</h4><p class="text-gray-400 mt-1">${item.insight || 'No details provided.'}</p></div>`;
                if (insights.summary) insightsResultEl.innerHTML += createInsightBlock(insights.summary);
                if (insights.biodiversity_assessment) {
                    const item = insights.biodiversity_assessment;
                    const infographicHTML = `<div class="grid grid-cols-2 gap-4 mt-3 pt-3 border-t border-[#27272a]/50"><div class="text-center p-2 bg-black/50 rounded-md"><div class="text-2xl font-bold text-white">${item.richness_value || 'N/A'}</div><div class="text-xs text-gray-400 uppercase tracking-wider font-mono">Taxa Richness</div></div><div class="text-center p-2 bg-black/50 rounded-md"><div class="text-2xl font-bold text-white">${item.evenness_category || 'N/A'}</div><div class="text-xs text-gray-400 uppercase tracking-wider font-mono">Evenness</div></div></div>`;
                    insightsResultEl.innerHTML += createInsightBlock(item) + infographicHTML;
                }
                if (insights.community_structure) {
                    const item = insights.community_structure;
                    let communityHTML = createInsightBlock(item);
                    
                    // Group by Phylum for better diversity visualization
                    const phylumCounts = {};
                    if (window.currentBatchResults && window.currentBatchResults.length > 0) {
                        window.currentBatchResults.forEach(result => {
                            if (result.phylum && result.phylum !== 'Unknown' && result.phylum !== 'N/A') {
                                phylumCounts[result.phylum] = (phylumCounts[result.phylum] || 0) + 1;
                            } else {
                                phylumCounts['Unclassified'] = (phylumCounts['Unclassified'] || 0) + 1;
                            }
                        });
                    }
                    
                    // Display phylum diversity chart if available
                    if (Object.keys(phylumCounts).length > 0) {
                        communityHTML += `<div class="mt-4 pt-4 border-t border-[#27272a]/50">`;
                        communityHTML += `<div class="text-xs text-gray-400 mb-3 text-center uppercase tracking-wider">Phylum-Level Diversity</div>`;
                        communityHTML += `<div class="w-full" style="height: 280px;"><canvas id="communityDonutChart"></canvas></div></div>`;
                        insightsResultEl.innerHTML += communityHTML;
                        
                        // Create chart with phylum groups
                        setTimeout(() => {
                            const labels = Object.keys(phylumCounts);
                            const data = Object.values(phylumCounts);
                            const chartInstance = Chart.getChart('communityDonutChart');
                            if(chartInstance) chartInstance.destroy();
                            const ctx = document.getElementById('communityDonutChart').getContext('2d');
                            
                            // Darker, muted color palette with subtle elegance
                            const colorPalette = [
                                { bg: 'rgba(59, 130, 246, 0.75)', border: 'rgb(37, 99, 235)', glow: 'rgba(59, 130, 246, 0.3)' },      // Deep Blue
                                { bg: 'rgba(236, 72, 153, 0.75)', border: 'rgb(219, 39, 119)', glow: 'rgba(236, 72, 153, 0.3)' },     // Deep Pink
                                { bg: 'rgba(16, 185, 129, 0.75)', border: 'rgb(5, 150, 105)', glow: 'rgba(16, 185, 129, 0.3)' },       // Deep Green
                                { bg: 'rgba(245, 158, 11, 0.75)', border: 'rgb(217, 119, 6)', glow: 'rgba(245, 158, 11, 0.3)' },       // Deep Amber
                                { bg: 'rgba(168, 85, 247, 0.75)', border: 'rgb(147, 51, 234)', glow: 'rgba(168, 85, 247, 0.3)' },      // Deep Purple
                                { bg: 'rgba(14, 165, 233, 0.75)', border: 'rgb(2, 132, 199)', glow: 'rgba(14, 165, 233, 0.3)' },       // Deep Cyan
                                { bg: 'rgba(239, 68, 68, 0.75)', border: 'rgb(220, 38, 38)', glow: 'rgba(239, 68, 68, 0.3)' },         // Deep Red
                                { bg: 'rgba(132, 204, 22, 0.75)', border: 'rgb(101, 163, 13)', glow: 'rgba(132, 204, 22, 0.3)' }       // Deep Lime
                            ];
                            
                            const backgroundColors = labels.map((_, i) => colorPalette[i % colorPalette.length].bg);
                            const borderColors = labels.map((_, i) => colorPalette[i % colorPalette.length].border);
                            
                            new Chart(ctx, { 
                                type: 'doughnut', 
                                data: { 
                                    labels: labels, 
                                    datasets: [{ 
                                        data: data, 
                                        backgroundColor: backgroundColors, 
                                        borderColor: borderColors, 
                                        borderWidth: 3,
                                        hoverOffset: 15,
                                        hoverBorderWidth: 4
                                    }] 
                                }, 
                                options: {
                                    animation: {
                                        animateRotate: true,
                                        animateScale: true,
                                        duration: 1200,
                                        easing: 'easeOutQuart'
                                    },
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    cutout: '60%',
                                    plugins: { 
                                        legend: { 
                                            position: 'right',
                                            align: 'center',
                                            labels: { 
                                                color: '#ffffff',  // White for UI (changed to black during PDF export)
                                                boxWidth: 18,
                                                boxHeight: 18,
                                                padding: 16,
                                                font: { 
                                                    family: "'Inter', sans-serif",
                                                    size: 12,
                                                    weight: '600'
                                                },
                                                usePointStyle: false,
                                                generateLabels: function(chart) {
                                                    const data = chart.data;
                                                    if (data.labels.length && data.datasets.length) {
                                                        return data.labels.map((label, i) => {
                                                            const meta = chart.getDatasetMeta(0);
                                                            const value = data.datasets[0].data[i];
                                                            const total = data.datasets[0].data.reduce((a, b) => a + b, 0);
                                                            const percentage = ((value / total) * 100).toFixed(1);
                                                            return {
                                                                text: `${label} (${percentage}%)`,
                                                                fillStyle: data.datasets[0].backgroundColor[i],
                                                                strokeStyle: data.datasets[0].borderColor[i],
                                                                lineWidth: 2,
                                                                fontColor: '#ffffff',  // White for UI
                                                                hidden: !meta.data[i] || meta.data[i].hidden,
                                                                index: i
                                                            };
                                                        });
                                                    }
                                                    return [];
                                                }
                                            } 
                                        },
                                        tooltip: {
                                            backgroundColor: 'rgba(0, 0, 0, 0.95)',
                                            padding: 14,
                                            titleColor: '#fff',
                                            titleFont: { size: 13, weight: 'bold' },
                                            bodyColor: '#d1d5db',
                                            bodyFont: { size: 12 },
                                            borderColor: 'rgba(255, 255, 255, 0.2)',
                                            borderWidth: 2,
                                            cornerRadius: 8,
                                            displayColors: true,
                                            callbacks: {
                                                label: function(context) {
                                                    const label = context.label || '';
                                                    const value = context.parsed;
                                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                                    const percentage = ((value / total) * 100).toFixed(1);
                                                    return [
                                                        `${label}`,
                                                        `Count: ${value}`,
                                                        `Percentage: ${percentage}%`
                                                    ];
                                                }
                                            }
                                        }
                                    } 
                                } 
                            });
                        }, 0);
                    } else {
                        insightsResultEl.innerHTML += communityHTML;
                    }
                } else {
                }
                if (insights.dominant_taxa) insightsResultEl.innerHTML += createInsightBlock(insights.dominant_taxa);
                if (insights.trophic_levels) insightsResultEl.innerHTML += createInsightBlock(insights.trophic_levels);
                if (insights.bioindicators) insightsResultEl.innerHTML += createInsightBlock(insights.bioindicators);
            }

            function populateSingleResult(apiData, markerLabel = '') {
                if (apiData) {
                    // Build clean lineage display
                    let lineageHTML = `<div class="p-5 bg-black/50 border border-[#27272a] rounded-lg">`;
                    
                    // Header with marker info
                    lineageHTML += `<div class="flex justify-between items-center mb-4 pb-3 border-b border-[#27272a]/50">`;
                    lineageHTML += `<div><span class="text-xs text-gray-500 uppercase tracking-wider">Gene Marker</span>`;
                    lineageHTML += `<div class="text-white font-semibold mt-1">${markerLabel}</div></div>`;
                    
                    // Novelty badge
                    if (apiData.is_novel) {
                        lineageHTML += `<div class="px-3 py-1 bg-yellow-500/10 border border-yellow-500/30 rounded-full">`;
                        lineageHTML += `<span class="text-yellow-400 font-bold text-xs">üÜï NOVEL</span></div>`;
                    } else {
                        lineageHTML += `<div class="px-3 py-1 bg-green-500/10 border border-green-500/30 rounded-full">`;
                        lineageHTML += `<span class="text-green-400 font-bold text-xs">‚úì KNOWN</span></div>`;
                    }
                    lineageHTML += `</div>`;
                    
                    // UID if novel
                    if (apiData.is_novel && apiData.uid) {
                        lineageHTML += `<div class="mb-4 p-3 bg-yellow-500/5 border border-yellow-500/20 rounded">`;
                        lineageHTML += `<div class="text-xs text-gray-400">Unique Identifier</div>`;
                        lineageHTML += `<div class="text-yellow-300 font-mono font-semibold mt-1">${apiData.uid}</div></div>`;
                    }
                    
                    // Taxonomic lineage - only show known levels
                    lineageHTML += `<div class="space-y-0 font-mono text-sm">`;
                    const lineageLevels = [
                        { label: 'Kingdom', value: apiData.kingdom, color: 'text-blue-400' },
                        { label: 'Phylum', value: apiData.phylum, color: 'text-cyan-400' },
                        { label: 'Class', value: apiData.class, color: 'text-teal-400' },
                        { label: 'Order', value: apiData.order, color: 'text-green-400' },
                        { label: 'Family', value: apiData.family, color: 'text-yellow-400' },
                        { label: 'Genus', value: apiData.genus, color: 'text-orange-400' },
                        { label: 'Species', value: apiData.species, color: 'text-red-400' }
                    ];
                    
                    let foundLast = false;
                    lineageLevels.forEach((level, index) => {
                        // Only show levels that have values and stop at first Unknown/N/A
                        if (!foundLast && level.value && level.value !== 'Unknown' && level.value !== 'N/A') {
                            const indent = '  '.repeat(index);
                            const connector = index > 0 ? '‚îî‚îÄ ' : '';
                            lineageHTML += `<div class="flex items-start py-1.5 hover:bg-white/5 rounded px-2 -mx-2 transition">`;
                            lineageHTML += `<span class="text-gray-600 w-28 text-xs flex-shrink-0">${indent}${connector}${level.label}</span>`;
                            lineageHTML += `<span class="${level.color} font-semibold flex-1">${level.value}</span>`;
                            lineageHTML += `</div>`;
                        } else if (!level.value || level.value === 'Unknown' || level.value === 'N/A') {
                            foundLast = true;
                        }
                    });
                    
                    lineageHTML += `</div></div>`;
                    
                    classificationResultEl.innerHTML = lineageHTML;
                    noveltyResultEl.innerHTML = apiData.is_novel 
                        ? `<div class="text-center"><div class="text-3xl font-bold text-yellow-400">1</div><div class="text-xs text-gray-400 mt-1">Novel Species</div><div class="text-xs text-yellow-500 mt-2 font-mono">${apiData.uid}</div></div>` 
                        : `<div class="text-center"><div class="text-3xl font-bold text-green-400">0</div><div class="text-xs text-gray-400 mt-1">Novel Species</div><div class="text-xs text-gray-500 mt-2">Known Classification</div></div>`;
                } else {
                    classificationResultEl.innerHTML = '<div class="text-gray-500">Analysis failed. See status.</div>';
                    noveltyResultEl.innerHTML = 'N/A';
                }
                updateAbundanceChart([]);
                insightsResultEl.innerHTML = '<p class="text-gray-500">Ecological insights are only available for batch analysis.</p>';
            }
           
            function updateAbundanceChart(results) {
                 // Smart grouping strategy: Group by Family > Order > Class > Phylum based on what's available
                 const counts = results.reduce((acc, result) => {
                     let groupName = 'Unclassified';
                     let groupLevel = '';
                     
                     // Priority grouping: prefer Family or Order for meaningful ecological groups
                     if (result.family && result.family !== 'Unknown' && result.family !== 'N/A') {
                         groupName = result.family;
                         groupLevel = 'Family';
                     } else if (result.order && result.order !== 'Unknown' && result.order !== 'N/A') {
                         groupName = result.order;
                         groupLevel = 'Order';
                     } else if (result.class && result.class !== 'Unknown' && result.class !== 'N/A') {
                         groupName = result.class;
                         groupLevel = 'Class';
                     } else if (result.phylum && result.phylum !== 'Unknown' && result.phylum !== 'N/A') {
                         groupName = result.phylum;
                         groupLevel = 'Phylum';
                     } else if (result.kingdom && result.kingdom !== 'Unknown' && result.kingdom !== 'N/A') {
                         groupName = result.kingdom;
                         groupLevel = 'Kingdom';
                     }
                     
                     // Use full name without abbreviation for cleaner display
                     acc[groupName] = (acc[groupName] || 0) + 1;
                     return acc;
                 }, {});
                 
                 // Sort by abundance and take top 15
                 const sortedTaxa = Object.entries(counts).sort((a, b) => b[1] - a[1]);
                 const topTaxa = sortedTaxa.slice(0, 15);
                 const labels = topTaxa.map(item => item[0]);
                 const data = topTaxa.map(item => item[1]);
                 
                 // Beautiful gradient colors - blue to cyan spectrum
                 const colors = data.map((value, index) => {
                     const ratio = index / Math.max(data.length - 1, 1);
                     const r = Math.round(59 + (34 - 59) * ratio);   // 59 -> 34
                     const g = Math.round(130 + (211 - 130) * ratio); // 130 -> 211
                     const b = Math.round(246 + (238 - 246) * ratio); // 246 -> 238
                     return `rgba(${r}, ${g}, ${b}, 0.85)`;
                 });
                 
                 const borderColors = data.map((value, index) => {
                     const ratio = index / Math.max(data.length - 1, 1);
                     const r = Math.round(59 + (34 - 59) * ratio);
                     const g = Math.round(130 + (211 - 130) * ratio);
                     const b = Math.round(246 + (238 - 246) * ratio);
                     return `rgb(${r}, ${g}, ${b})`;
                 });
                 
                 const abundanceChartInstance = Chart.getChart('abundanceChart');
                 if(abundanceChartInstance) abundanceChartInstance.destroy();
                 
                 const ctx = document.getElementById('abundanceChart').getContext('2d');
                 Chart.defaults.font.family = "'Roboto Mono', monospace";
                 Chart.defaults.color = '#ffffff';
                 
                 new Chart(ctx, { 
                     type: 'bar', 
                     data: { 
                         labels: labels, 
                         datasets: [{ 
                             label: 'Abundance', 
                             data: data, 
                             backgroundColor: colors,
                             borderColor: borderColors,
                             borderWidth: 2,
                             borderRadius: 6,
                             borderSkipped: false
                         }] 
                     }, 
                     options: {
                         animation: {
                             duration: 1000,
                             easing: 'easeOutQuart'
                         },
                         indexAxis: 'y', 
                         responsive: true, 
                         maintainAspectRatio: true,
                         scales: { 
                             y: { 
                                 ticks: { 
                                     color: '#d1d5db', 
                                     font: {size: 10, weight: '500'},
                                     padding: 8,
                                     callback: function(value, index) {
                                         const label = this.getLabelForValue(value);
                                         if (label.length > 30) {
                                             return label.substring(0, 27) + '...';
                                         }
                                         return label;
                                     }
                                 }, 
                                 grid: { 
                                     display: false
                                 },
                                 border: {
                                     display: false
                                 }
                             }, 
                             x: { 
                                 ticks: { 
                                     color: '#9ca3af',
                                     font: {size: 10},
                                     stepSize: 1,
                                     precision: 0,
                                     callback: function(value) {
                                         // Only show integer values
                                         if (Number.isInteger(value)) {
                                             return value;
                                         }
                                         return null;
                                     }
                                 }, 
                                 grid: { 
                                     color: 'rgba(63, 63, 70, 0.3)',
                                     drawBorder: false
                                 },
                                 border: {
                                     display: false
                                 },
                                 title: { 
                                     display: true, 
                                     text: 'Number of Sequences', 
                                     color: '#9ca3af', 
                                     font: { size: 11, weight: '600' },
                                     padding: { top: 10 }
                                 },
                                 min: 0,
                                 beginAtZero: true
                             } 
                         }, 
                         plugins: { 
                             legend: { 
                                 display: false 
                             }, 
                             title: { 
                                 display: labels.length === 0, 
                                 text: 'No batch data to display', 
                                 color: '#6b7280', 
                                 font: {size: 12} 
                             },
                             tooltip: {
                                 backgroundColor: 'rgba(0, 0, 0, 0.95)',
                                 padding: 14,
                                 titleColor: '#fff',
                                 titleFont: { size: 13, weight: 'bold' },
                                 bodyColor: '#d1d5db',
                                 bodyFont: { size: 12 },
                                 borderColor: 'rgba(59, 130, 246, 0.5)',
                                 borderWidth: 2,
                                 cornerRadius: 8,
                                 displayColors: false,
                                 callbacks: {
                                     title: function(context) {
                                         return context[0].label;
                                     },
                                     label: function(context) {
                                         const count = context.parsed.x;
                                         const total = data.reduce((sum, val) => sum + val, 0);
                                         const percentage = ((count / total) * 100).toFixed(1);
                                         return [
                                             `Sequences: ${count}`,
                                             `Percentage: ${percentage}%`
                                         ];
                                     }
                                 }
                             }
                         },
                         layout: {
                             padding: {
                                 left: 5,
                                 right: 15,
                                 top: 10,
                                 bottom: 10
                             }
                         }
                     } 
                 });
            }

            function generateSummaryPdfReport(insights) {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: "portrait", unit: "mm", format: "a4" });

                const docWidth = doc.internal.pageSize.getWidth();
                const docHeight = doc.internal.pageSize.getHeight();
                const margin = 15;
                let yPos = margin;

                doc.setFont("helvetica", "bold");
                doc.setFontSize(20);
                doc.text("Ecological Insights Report", docWidth / 2, yPos, { align: "center" });
                yPos += 15;

                doc.setFontSize(10);
                doc.setFont("helvetica", "normal");
                const environment = document.getElementById('environmentType').value || 'Not Specified';
                const depth = document.getElementById('batchDepth').value || 'Not Specified';
                doc.text(`Environment: ${environment}`, margin, yPos);
                doc.text(`Depth: ${depth} meters`, docWidth - margin, yPos, { align: "right" });
                yPos += 6;
                doc.setLineWidth(0.2);
                doc.line(margin, yPos, docWidth - margin, yPos);
                yPos += 10;

                const renderSection = (item) => {
                    if (!item) return;
                     if (yPos > docHeight - 30) { 
                         doc.addPage();
                         yPos = margin;
                     }
                    doc.setFont("helvetica", "bold");
                    doc.setFontSize(12);
                    doc.text(item.title, margin, yPos);
                    yPos += 6;
                    doc.setFont("helvetica", "normal");
                    doc.setFontSize(10);
                    const lines = doc.splitTextToSize(item.insight, docWidth - margin * 2);
                    doc.text(lines, margin, yPos);
                    yPos += (lines.length * 5);

                    if (item.richness_value !== undefined) {
                         yPos += 2;
                         doc.text(`Taxa Richness: ${item.richness_value} | Evenness: ${item.evenness_category}`, margin, yPos);
                         yPos += 5;
                    }
                     if (item.protist_count !== undefined) {
                         const communityChartCanvas = document.getElementById('communityDonutChart');
                         if (communityChartCanvas) {
                             const communityChartImg = communityChartCanvas.toDataURL('image/png', 1.0);
                             if (yPos > docHeight - 60) {
                                 doc.addPage();
                                 yPos = margin;
                             }
                             doc.addImage(communityChartImg, 'PNG', docWidth / 2 - 25, yPos, 50, 50);
                             yPos += 55;
                         }
                     }
                    yPos += 8;
                };
               
                Object.values(insights).forEach(renderSection);

                const pageCount = doc.internal.getNumberOfPages();
                for(let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFontSize(10);
                    doc.setTextColor(150);
                    doc.text('Report by Bio-Line', docWidth / 2, docHeight - 10, { align: 'center' });
                }

                doc.save('Bio-Line-Summary-Report.pdf');
            }
           
            async function generateDetailedPdfReport() {
                modalButtons.classList.add('hidden');
                modalLoader.classList.remove('hidden');

                const environment = document.getElementById('environmentType').value || 'Not Specified';
                const depth = document.getElementById('batchDepth').value || 'Not Specified';
                
                // Calculate diversity metrics for the report
                const diversityMetrics = calculateDiversityMetrics(window.currentBatchResults || []);
                
                // Generate mock detailed report content
                await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate processing
                
                const numResults = window.currentBatchResults?.length || 0;
                const numNovel = window.currentBatchResults?.filter(r => r.is_novel).length || 0;
                const numSpecies = new Set(window.currentBatchResults?.map(r => r.species)).size || 0;
                
                const markdownText = `# Executive Summary

This eDNA analysis examined ${numResults} sequences from a ${environment} environment at ${depth} meters depth. The analysis identified ${numSpecies} unique taxa, with ${numNovel} sequences flagged as potentially novel species not found in current reference databases.

The community composition indicates a diverse marine ecosystem with representatives from multiple phyla. Key findings suggest this habitat harbors significant biodiversity worthy of continued monitoring and potential conservation attention.

# Introduction & Methodology

Environmental DNA (eDNA) metabarcoding is a powerful tool for biodiversity assessment, allowing detection of organisms through DNA traces left in the environment. This non-invasive approach enables comprehensive species surveys without physical capture or direct observation.

The Bio-Line pipeline processes raw eDNA sequences through several stages: quality filtering, marker gene extraction (targeting COI and 18S rRNA regions), AI-powered taxonomic classification using transformer-based models, and ecological insight generation.

The COI (Cytochrome c oxidase subunit I) gene is particularly effective for animal identification, while 18S rRNA provides broader eukaryotic coverage. Together, these markers enable comprehensive community profiling.

# Biodiversity Assessment

## Diversity Metrics Analysis

The Shannon Index (H') of ${diversityMetrics?.alpha?.shannonIndex || 'N/A'} indicates ${parseFloat(diversityMetrics?.alpha?.shannonIndex) > 2 ? 'high' : 'moderate'} species diversity in this sample. The Simpson Index (D) of ${diversityMetrics?.alpha?.simpsonIndex || 'N/A'} represents the probability of two randomly selected individuals belonging to the same species.

Pielou's Evenness (J') of ${diversityMetrics?.alpha?.pielouEvenness || 'N/A'} suggests ${parseFloat(diversityMetrics?.alpha?.pielouEvenness) > 0.7 ? 'relatively even species distribution' : 'some dominance by particular taxa'}. These metrics together paint a picture of ${numSpecies > 10 ? 'a highly diverse' : 'a moderately diverse'} community.

## Community Composition

The analyzed community shows representation from multiple marine phyla including Arthropoda, Chordata, Mollusca, and Cnidaria. This taxonomic breadth indicates a complex ecosystem with multiple trophic levels and ecological niches filled.

## Dominant Taxa & Ecological Roles

The most frequently detected taxa play crucial roles in marine food webs. Arthropods (particularly crustaceans) serve as important links between primary producers and higher predators. Chordates detected include both fish and potentially marine mammal DNA, indicating the presence of apex predators.

# Detailed Findings

| Sample ID | Detected Gene | Predicted Taxa |
|-----------|---------------|----------------|
${detailedReportData.slice(0, 15).map(d => `| ${d.id} | ${d.gene} | ${d.taxa} |`).join('\n')}

# Analysis of Potential Threats & Conservation

Based on the community composition and ${environment} environment, several ecological considerations emerge:

- Climate Change: Rising ocean temperatures and acidification may affect the detected calcifying organisms and temperature-sensitive species.
- Habitat Disturbance: ${depth > 1000 ? 'Deep-sea environments face potential threats from mining activities and bottom trawling.' : 'Coastal environments face pressures from development and pollution.'}
- Biodiversity Loss: The detection of ${numNovel} potentially novel species highlights knowledge gaps and the importance of protecting under-studied habitats.

Conservation Recommendations:
1. Establish baseline monitoring using eDNA surveys at regular intervals
2. ${numNovel > 0 ? 'Prioritize taxonomic investigation of novel sequences through specimen collection' : 'Continue monitoring for invasive species detection'}
3. Implement habitat protection measures appropriate for the ${environment} environment

# Conclusion

This eDNA analysis demonstrates the power of molecular biodiversity assessment for characterizing marine communities. The detection of ${numSpecies} taxa including ${numNovel} potentially novel species underscores both the biodiversity value of this habitat and our incomplete understanding of marine life.

Future research should focus on temporal monitoring to detect community changes, expanded geographic sampling, and taxonomic resolution of novel sequences through integrated approaches combining molecular and morphological methods.`;
                try {
                    // Using mock data - no actual API call needed
                    // markdownText is already generated above
                   
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({ orientation: "portrait", unit: "mm", format: "a4" });
                    const docWidth = doc.internal.pageSize.getWidth();
                    const docHeight = doc.internal.pageSize.getHeight();
                    const margin = 15;
                    let yPos = 0;
                   
                    const addHeader = (text) => {
                        doc.setFont("helvetica", "bold");
                        doc.setFontSize(14);
                        doc.setTextColor(0,0,0);
                        doc.text(text, docWidth / 2, margin, { align: "center"});
                        yPos = margin + 15;
                    };

                    const addFooter = () => {
                        const pageCount = doc.internal.getNumberOfPages();
                        for(let i = 1; i <= pageCount; i++) {
                            doc.setPage(i);
                            doc.setLineWidth(0.2);
                            doc.setDrawColor(200);
                            doc.line(margin, docHeight - 18, docWidth - margin, docHeight - 18);
                            doc.setFontSize(9);
                            doc.setTextColor(100);
                            doc.text(`Report by Bio-Line // CMLRE Initiative`, margin, docHeight - 10);
                            doc.text(`Page ${i} of ${pageCount}`, docWidth - margin, docHeight - 10, { align: 'right' });
                        }
                    };

                    const checkPageBreak = (neededHeight) => {
                        if (yPos + neededHeight > docHeight - 25) {
                           doc.addPage();
                           yPos = margin;
                        }
                    };

                    addHeader("Detailed Ecological Insights Report");
                   
                    // Clean markdown text to remove formatting artifacts that cause ***text*** issues
                    const cleanedMarkdown = markdownText
                        .replace(/\*\*\*([^*]+)\*\*\*/g, '$1')  // Remove bold+italic ***text***
                        .replace(/\*\*([^*]+)\*\*/g, '$1')      // Remove bold **text**
                        .replace(/\*([^*]+)\*/g, '$1')          // Remove italic *text*
                        .replace(/__([^_]+)__/g, '$1')          // Remove bold __text__
                        .replace(/_([^_]+)_/g, '$1');           // Remove italic _text_
                   
                    const lines = cleanedMarkdown.split('\n');
                    for (const line of lines) {
                        let trimmedLine = line.trim();
                       
                        if (trimmedLine.startsWith('# ')) {
                            checkPageBreak(20);
                            yPos += 8;
                            doc.setFont("helvetica", "bold");
                            doc.setFontSize(16);
                            doc.setTextColor(0,0,0);
                            const text = trimmedLine.substring(2);
                            const splitText = doc.splitTextToSize(text, docWidth - margin * 2);
                            doc.text(splitText, margin, yPos);
                            yPos += (splitText.length * 7) + 2;
                            doc.setLineWidth(0.2);
                            doc.setDrawColor(200);
                            doc.line(margin, yPos-2, margin + 50, yPos-2);
                            yPos += 5;

                        } else if (trimmedLine.startsWith('## ')) {
                            checkPageBreak(15);
                            yPos += 6;
                            doc.setFont("helvetica", "bold");
                            doc.setFontSize(12);
                             doc.setTextColor(50,50,50);
                            const text = trimmedLine.substring(3);
                            const splitText = doc.splitTextToSize(text, docWidth - margin * 2);
                            doc.text(splitText, margin, yPos);
                            yPos += (splitText.length * 6) + 4;

                        } else if (trimmedLine.startsWith('* ') || trimmedLine.startsWith('- ')) {
                             checkPageBreak(8);
                             doc.setFont("helvetica", "normal");
                             doc.setFontSize(10);
                             doc.setTextColor(0,0,0);
                             const text = trimmedLine.substring(2);
                             const splitText = doc.splitTextToSize(text, docWidth - (margin * 2) - 5);
                             doc.text("‚Ä¢", margin, yPos + 1, { baseline: 'top' });
                             doc.text(splitText, margin + 5, yPos);
                             yPos += (splitText.length * 5) + 2;
                       
                        } else if (trimmedLine.startsWith('|')) {
                            checkPageBreak(5);
                            doc.setFont("courier", "normal");
                            doc.setFontSize(8);
                            doc.setTextColor(80,80,80);
                            doc.text(trimmedLine.replace(/\|/g, '  '), margin, yPos);
                            yPos += 4;

                        } else if (trimmedLine.length > 0) {
                            checkPageBreak(10);
                            doc.setFont("helvetica", "normal");
                            doc.setFontSize(10);
                            doc.setTextColor(0,0,0);
                            const splitText = doc.splitTextToSize(trimmedLine, docWidth - margin * 2);
                            doc.text(splitText, margin, yPos);
                            yPos += (splitText.length * 5) + 3;
                        }

                        if (trimmedLine.toLowerCase().includes('## community composition')) {
                            const abundanceChartCanvas = document.getElementById('abundanceChart');
                            if(abundanceChartCanvas) {
                                const abundanceChartImg = abundanceChartCanvas.toDataURL('image/png', 1.0);
                                checkPageBreak(80);
                                yPos += 5;
                                doc.addImage(abundanceChartImg, 'PNG', margin, yPos, docWidth - (margin * 2), 70);
                                yPos += 75;
                                doc.setFontSize(8);
                                doc.setTextColor(150);
                                doc.text('Figure 1: Top 15 most abundant taxa identified in the sample.', docWidth / 2, yPos, {align: 'center'});
                                yPos += 10;
                            }
                        }
                        if(currentInsightsData.community_structure && trimmedLine.toLowerCase().includes('## community composition')) {
                            const communityChartCanvas = document.getElementById('communityDonutChart');
                            if(communityChartCanvas) {
                                // Temporarily change chart legend color to black for PDF export
                                const chart = Chart.getChart('communityDonutChart');
                                const originalLegendColor = chart.options.plugins.legend.labels.color;
                                chart.options.plugins.legend.labels.color = '#000000';
                                chart.options.plugins.legend.labels.generateLabels = function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        return data.labels.map((label, i) => {
                                            const meta = chart.getDatasetMeta(0);
                                            const value = data.datasets[0].data[i];
                                            const total = data.datasets[0].data.reduce((a, b) => a + b, 0);
                                            const percentage = ((value / total) * 100).toFixed(1);
                                            return {
                                                text: `${label} (${percentage}%)`,
                                                fillStyle: data.datasets[0].backgroundColor[i],
                                                strokeStyle: data.datasets[0].borderColor[i],
                                                lineWidth: 2,
                                                fontColor: '#000000',  // Black for PDF
                                                hidden: !meta.data[i] || meta.data[i].hidden,
                                                index: i
                                            };
                                        });
                                    }
                                    return [];
                                };
                                chart.update();
                                
                                // Export to PDF
                                const communityChartImg = communityChartCanvas.toDataURL('image/png', 1.0);
                                checkPageBreak(80);
                                yPos += 5;
                                doc.addImage(communityChartImg, 'PNG', docWidth / 2 - 40, yPos, 80, 80);
                                yPos += 85;
                                doc.setFontSize(8);
                                doc.setTextColor(150);
                                doc.text('Figure 2: Proportional abundance of Protista vs. Metazoa.', docWidth / 2, yPos, {align: 'center'});
                                yPos += 10;
                                
                                // Restore original color for UI
                                chart.options.plugins.legend.labels.color = originalLegendColor;
                                chart.options.plugins.legend.labels.generateLabels = function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        return data.labels.map((label, i) => {
                                            const meta = chart.getDatasetMeta(0);
                                            const value = data.datasets[0].data[i];
                                            const total = data.datasets[0].data.reduce((a, b) => a + b, 0);
                                            const percentage = ((value / total) * 100).toFixed(1);
                                            return {
                                                text: `${label} (${percentage}%)`,
                                                fillStyle: data.datasets[0].backgroundColor[i],
                                                strokeStyle: data.datasets[0].borderColor[i],
                                                lineWidth: 2,
                                                fontColor: '#ffffff',  // White for UI
                                                hidden: !meta.data[i] || meta.data[i].hidden,
                                                index: i
                                            };
                                        });
                                    }
                                    return [];
                                };
                                chart.update();
                            }
                        }
                    }

                    addFooter();
                    doc.save('Bio-Line-Detailed-Report.pdf');

                } catch (error) {
                    alert("Failed to generate detailed report: " + error.message);
                } finally {
                    modalButtons.classList.remove('hidden');
                    modalLoader.classList.add('hidden');
                    reportModal.classList.add('hidden');
                }
            }

            // --- Chatbot Logic ---
            if (chatBtn) {
                chatBtn.addEventListener('click', () => {
                chatbotContainer.classList.remove('hidden');
                if (chatMessages.children.length === 0) {
                    appendMessage("Hello! I'm the Bio-Line AI assistant. How can I help you interpret these ecological insights?", 'bot');
                }
                });
            }

            if (closeChatbotBtn) {
                closeChatbotBtn.addEventListener('click', () => {
                    if (chatbotContainer) chatbotContainer.classList.add('hidden');
                });
            }

            if (chatForm) {
                chatForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const userInput = chatInput.value.trim();
                if (!userInput) return;

                appendMessage(userInput, 'user');
                chatInput.value = '';
                appendMessage('...', 'bot', true); // Thinking indicator

                try {
                    const botResponse = await askGeminiForChat(userInput);
                    const thinkingIndicator = document.getElementById('thinking');
                    if (thinkingIndicator) thinkingIndicator.parentElement.remove();
                    appendMessage(botResponse, 'bot');
                } catch (error) {
                    console.error("Chatbot API call failed:", error);
                    const thinkingIndicator = document.getElementById('thinking');
                    if (thinkingIndicator) thinkingIndicator.parentElement.remove();
                    appendMessage("Sorry, I encountered an error. Please try again.", 'bot');
                }
                });
            }

            function appendMessage(text, sender, isThinking = false) {
                const messageWrapper = document.createElement('div');
                messageWrapper.className = `flex w-full ${sender === 'user' ? 'justify-end' : 'justify-start'}`;

                const messageElement = document.createElement('div');
                messageElement.className = `max-w-xs md:max-w-md p-3 rounded-lg text-sm`;

                if (sender === 'user') {
                    messageElement.classList.add('bg-white', 'text-black');
                } else {
                    messageElement.classList.add('bg-[#18181b]', 'text-gray-300', 'border', 'border-[#27272a]');
                }
               
                if (isThinking) {
                    messageElement.id = 'thinking';
                    messageElement.innerHTML = `<div class="flex items-center space-x-1 p-1">
                        <div class="w-2 h-2 bg-gray-500 rounded-full animate-pulse" style="animation-delay: 0s;"></div>
                        <div class="w-2 h-2 bg-gray-500 rounded-full animate-pulse" style="animation-delay: 0.2s;"></div>
                        <div class="w-2 h-2 bg-gray-500 rounded-full animate-pulse" style="animation-delay: 0.4s;"></div>
                    </div>`;
                } else {
                    text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    messageElement.innerHTML = text;
                }
               
                messageWrapper.appendChild(messageElement);
                chatMessages.appendChild(messageWrapper);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            async function askGeminiForChat(question) {
                if (!currentInsightsData) {
                    return "The ecological insights data isn't available. Please run a batch analysis first.";
                }
                
                // Using mock chatbot - no actual API call
                return await mockChatbotResponse(question, currentInsightsData);
            }

            // Modal listeners
            generateReportBtn.addEventListener('click', () => {
                reportModal.classList.remove('hidden');
            });
            closeModalBtn.addEventListener('click', () => {
                reportModal.classList.add('hidden');
            });
            downloadSummaryReportBtn.addEventListener('click', () => {
                if (currentInsightsData) {
                    generateSummaryPdfReport(currentInsightsData);
                }
                 reportModal.classList.add('hidden');
            });
            downloadDetailedReportBtn.addEventListener('click', () => {
                generateDetailedPdfReport();
            });

        });
    </script>
</body>
</html>